{"meta":{"title":"Xiao5's Blog","subtitle":"","description":"","author":"Tigerwcheng","url":"https://ccxiao5.github.io","root":"/"},"pages":[{"title":"关于|About","date":"2021-07-16T02:53:44.121Z","updated":"2021-07-16T02:53:44.121Z","comments":false,"path":"about/index.html","permalink":"https://ccxiao5.github.io/about/index.html","excerpt":"","text":"我来自湖北广水，目前于北京交通大学攻读全日制学术型硕士。"},{"title":"分类|categories","date":"2021-07-16T03:20:38.787Z","updated":"2021-07-16T03:20:38.787Z","comments":false,"path":"categories/index.html","permalink":"https://ccxiao5.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单|Books","date":"2021-07-16T03:02:32.469Z","updated":"2021-07-16T03:02:32.469Z","comments":false,"path":"books/index.html","permalink":"https://ccxiao5.github.io/books/index.html","excerpt":"","text":"推荐书单：《7470》 《4740》 《情商》 《地位》 《格局》 PS：在我人生最迷茫的时候，正是这些书籍的陪伴让我走出困境，在此推荐给大家。"},{"title":"标签|tags","date":"2021-07-16T02:55:24.343Z","updated":"2021-07-16T02:55:24.343Z","comments":false,"path":"tags/index.html","permalink":"https://ccxiao5.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2021-07-13T10:01:34.483Z","updated":"2021-07-19T08:33:41.045Z","comments":true,"path":"2021/07/13/hello-world/","link":"","permalink":"https://ccxiao5.github.io/2021/07/13/hello-world/","excerpt":"","text":"H=−∑i=1N(σixσi+1x+gσiz)H=-\\sum_{i=1}^N (\\sigma_{i}^x \\sigma_{i+1}^x+g \\sigma_{i}^z) H=−i=1∑N​(σix​σi+1x​+gσiz​) f(n)={n2,if n is even3n+1,if n is oddf(n) = \\begin{cases} \\frac{n}{2}, &amp; \\text{if } n\\text{ is even} \\\\ 3n+1, &amp; \\text{if } n\\text{ is odd} \\end{cases} f(n)={2n​,3n+1,​if n is evenif n is odd​ PPI(每英寸多少像素)象素数PPI=英寸数\\dfrac{PPI(每英寸多少像素)象素数}{PPI} = 英寸数 PPIPPI(每英寸多少像素)象素数​=英寸数 英寸数×25.4=毫米数英寸数\\times 25.4 = 毫米数 英寸数×25.4=毫米数 Var[x]Var[y]\\sqrt{Var[x]Var[y]} Var[x]Var[y]​ (790−152)2+(281−247)2=1.71m\\sqrt{(790-152)^2+(281-247)^2}=1.71m (790−152)2+(281−247)2​=1.71m Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"pip3安装报错：Cannot uninstall 'six'. It is a distutils installed project and thus we cannot accurately determine which files belong to it which would lead to only a partial uninstall.","slug":"pip3安装报错：Cannot-uninstall-six-It-is-a-distutils-installed-project-and-thus-we-cannot-accurately-determine-which-files-belong-to-it-which-would-lead-to-only-a-partial-uninstall","date":"2019-07-29T11:09:00.000Z","updated":"2021-07-19T09:36:54.718Z","comments":true,"path":"2019/07/29/pip3安装报错：Cannot-uninstall-six-It-is-a-distutils-installed-project-and-thus-we-cannot-accurately-determine-which-files-belong-to-it-which-would-lead-to-only-a-partial-uninstall/","link":"","permalink":"https://ccxiao5.github.io/2019/07/29/pip3%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99%EF%BC%9ACannot-uninstall-six-It-is-a-distutils-installed-project-and-thus-we-cannot-accurately-determine-which-files-belong-to-it-which-would-lead-to-only-a-partial-uninstall/","excerpt":"","text":"12Cannot uninstall &#x27;six&#x27;. It is a distutils installed project and thus we cannot accurately determine which files belong to it which would lead to only a partial uninstall. 解决方法如下： sudo pip3 install --ignore-installed six","categories":[{"name":"python","slug":"python","permalink":"https://ccxiao5.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ccxiao5.github.io/tags/python/"}]},{"title":"安装Python遇到问题——有 6 个软件包没有被完全安装或卸载。","slug":"安装Python遇到问题——有-6-个软件包没有被完全安装或卸载。","date":"2019-07-29T11:01:00.000Z","updated":"2021-07-19T09:33:09.851Z","comments":true,"path":"2019/07/29/安装Python遇到问题——有-6-个软件包没有被完全安装或卸载。/","link":"","permalink":"https://ccxiao5.github.io/2019/07/29/%E5%AE%89%E8%A3%85Python%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E6%9C%89-6-%E4%B8%AA%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%AE%8C%E5%85%A8%E5%AE%89%E8%A3%85%E6%88%96%E5%8D%B8%E8%BD%BD%E3%80%82/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Desktop sudo apt-get install python-matplotlib正在读取软件包列表... 完成正在分析软件包的依赖关系树 正在读取状态信息... 完成 python-matplotlib 已经是最新的版本。升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 19 个软件包未被升级。有 6 个软件包没有被完全安装或卸载。解压缩后会消耗 0 B 的额外空间。您希望继续执行吗？ [Y/n] Y正在设置 python-dateutil (1.5+dfsg-1ubuntu1) ...Traceback (most recent call last): File &quot;/usr/bin/pycompile&quot;, line 35, in &lt;module&gt; from debpython.version import SUPPORTED, debsorted, vrepr, \\ File &quot;/usr/share/python/debpython/version.py&quot;, line 24, in &lt;module&gt; from ConfigParser import SafeConfigParserImportError: No module named &#x27;ConfigParser&#x27;dpkg: 处理软件包 python-dateutil (--configure)时出错： 子进程 已安装 post-installation 脚本 返回了错误号 1正在设置 python-decorator (3.4.0-2build1) ...Traceback (most recent call last): File &quot;/usr/bin/pycompile&quot;, line 35, in &lt;module&gt; from debpython.version import SUPPORTED, debsorted, vrepr, \\ File &quot;/usr/share/python/debpython/version.py&quot;, line 24, in &lt;module&gt; from ConfigParser import SafeConfigParserImportError: No module named &#x27;ConfigParser&#x27;dpkg: 处理软件包 python-decorator (--configure)时出错： 子进程 已安装 post-installation 脚本 返回了错误号 1正在设置 python-pyparsing (2.0.1+dfsg1-1build1) ...Traceback (most recent call last): File &quot;/usr/bin/pycompile&quot;, line 35, in &lt;module&gt; from debpython.version import SUPPORTED, debsorted, vrepr, \\ File &quot;/usr/share/python/debpython/version.py&quot;, line 24, in &lt;module&gt; from ConfigParser import SafeConfigParserImportError: No module named &#x27;ConfigParser&#x27;dpkg: 处理软件包 python-pyparsing (--configure)时出错： 子进程 已安装 post-installation 脚本 返回了错误号 1正在设置 python-support (1.0.15) ... File &quot;/usr/sbin/update-python-modules&quot;, line 52 print x ^SyntaxError: Missing parentheses in call to &#x27;print&#x27;dpkg: 处理软件包 python-support (--configure)时出错： 子进程 已安装 post-installation 脚本 返回了错误号 1由于已经达到 MaxReports 限制，没有写入 apport 报告。 dpkg: 依赖关系问题使得 python-matplotlib 的配置工作不能继续： python-matplotlib 依赖于 python-dateutil；然而： 软件包 python-dateutil 尚未配置。 python-matplotlib 依赖于 python-pyparsing；然而： 软件包 python-pyparsing 尚未配置。 python-matplotlib 依赖于 python-support (&gt;= 0.90.0)；然而： 软件包 python-support 尚未配置。dpkg: 处理软件包 python-matplotlib (--configure)时出错： 依赖关系问题 - 仍未被配置由于已经达到 MaxReports 限制，没有写入 apport 报告。 dpkg: 依赖关系问题使得 python-scipy 的配置工作不能继续： python-scipy 依赖于 python-decorator；然而： 软件包 python-decorator 尚未配置。dpkg: 处理软件包 python-scipy (--configure)时出错： 依赖关系问题 - 仍未被配置由于已经达到 MaxReports 限制，没有写入 apport 报告。 在处理时有错误发生： python-dateutil python-decorator python-pyparsing python-support python-matplotlib python-scipyE: Sub-process /usr/bin/dpkg returned an error code (1) 原因是,我们在将python2.7升级到python3.3时,只是将/usr/local/bin目录下修改了(使用ln -s 或者其他),然而我们的配置目录并没有修改… 解决方法如下： 123sudo apt-get cleansudo apt-get updatesudo apt-get install --reinstall python-minimal python-lockfile","categories":[{"name":"python","slug":"python","permalink":"https://ccxiao5.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ccxiao5.github.io/tags/python/"}]},{"title":"解决OpenCV中Python3 import cv2的错误","slug":"解决OpenCV中Python3-import-cv2的错误","date":"2019-07-28T05:48:00.000Z","updated":"2021-07-19T09:31:46.658Z","comments":true,"path":"2019/07/28/解决OpenCV中Python3-import-cv2的错误/","link":"","permalink":"https://ccxiao5.github.io/2019/07/28/%E8%A7%A3%E5%86%B3OpenCV%E4%B8%ADPython3-import-cv2%E7%9A%84%E9%94%99%E8%AF%AF/","excerpt":"","text":"首先更换源，见Ubuntu14 安装 OpenCV3.0.0记得更新库。然后依次进行以下操作。 一、安装Python-dev 12sudo apt-get install aptitude sudo aptitude install python-dev 二、安装pip3 12sudo apt-get install python3-pipsudo pip3 install --upgrade pip 三、安装CV2 12sudo apt-get updatesudo pip3 install opencv-python 最后顺带安装numpy, scipy, matplotlib 记得更改权限 1234pip3 install numpypip3 install scipypip3 install matplotlibpip3 install pandas 如果系统有python2和python3，将python3设置为默认 12sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 100sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150","categories":[{"name":"树莓派","slug":"树莓派","permalink":"https://ccxiao5.github.io/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://ccxiao5.github.io/tags/OpenCV/"},{"name":"c++","slug":"c","permalink":"https://ccxiao5.github.io/tags/c/"}]},{"title":"OpenCV中各函数解释","slug":"OpenCV中各函数解释","date":"2019-07-24T09:33:00.000Z","updated":"2021-07-19T09:19:36.540Z","comments":true,"path":"2019/07/24/OpenCV中各函数解释/","link":"","permalink":"https://ccxiao5.github.io/2019/07/24/OpenCV%E4%B8%AD%E5%90%84%E5%87%BD%E6%95%B0%E8%A7%A3%E9%87%8A/","excerpt":"","text":"123456789101112131415161718192021import cv2clicked =Falsedef onMouse(event,x,y,flags,param): global clicked if event == cv2.EVENT_LBUTTONUP: clicked=TruecameraCapture =cv2.VideoCapture(0)cv2.namedWindow(&quot;MyWindow&quot;,0)cv2.resizeWindow(&quot;MyWindow&quot;,640,480)cv2.setMouseCallback(&quot;MyWindow&quot;,onMouse)print &quot;Showing camera feed.Click window or press any key to stop.&quot;success,frame=cameraCapture.read()while success and cv2.waitKey(1)==-1 and not clicked: cv2.imshow(&quot;MyWindow&quot;,frame) success,frame=cameraCapture.read()cv2.destroyWindow(&quot;MyWindow&quot;)cameraCapture.release() 一、namedWindow(const String,ing flag) Flag=0，表示按原图尺寸显示 Flag=1，表示窗口可以自适应 二、waitKey() waitKey()与waitKey(0)表示无线等待,针对视频流来说,cv2.waitKey(0)表示只显示当前帧图像，相当于暂停 waitKey(n)表示等待n毫秒关闭窗口，针对视频流来说,cv2.waitKey(1)表示延时1ms切换到下一帧 当等待时间内无任何操作，等待结束返回-1 如果等待时间内有输入字符那么返回该字符的ASCII值 e.g. while(waitKey(1)!=‘q’): 或者如上程序while waitKey(1)== -1: 针对第一个:waitKey(1)表示延迟一秒；while waitKey(1):表示一直延迟；while(waitKey(1)!=‘q’):表示一直延迟直到键入q时 针对第二个:前面同理；while waitKey(1)== -1:表示一直延迟，不键入字符。 三、VideoCapture()和read() cameraCapture=cv2.VideoCapture(0) success,frame = cameraCapture.read() VideoCapture(0)表示打开笔记本内置摄像头,还可以VideoCapture(&quot;…/test.avi&quot;) read()函数表示按帧读取视频，success，frame是read()的两个返回值，success是布尔值——如果读取帧是正确的则返回True，如果文件读取到结尾则返回False，Frame表示的是每一帧的图像，是一个三维矩阵","categories":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://ccxiao5.github.io/categories/OpenCV/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://ccxiao5.github.io/tags/OpenCV/"},{"name":"c++","slug":"c","permalink":"https://ccxiao5.github.io/tags/c/"}]},{"title":"Ubuntu14 安装 OpenCV3.0.0","slug":"Ubuntu14-安装-OpenCV3-0-0","date":"2019-07-23T09:35:00.000Z","updated":"2021-07-19T09:12:55.008Z","comments":true,"path":"2019/07/23/Ubuntu14-安装-OpenCV3-0-0/","link":"","permalink":"https://ccxiao5.github.io/2019/07/23/Ubuntu14-%E5%AE%89%E8%A3%85-OpenCV3-0-0/","excerpt":"","text":"Ubuntu新源 1234567# 备份sudo cp /etc/apt/sources.list /etc/apt/sources.list.old# 修改sudo gedit /etc/apt/sources.list# 更新sudo apt-get updatesudo apt-get upgrade 12345678910deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 一、使用Ubuntu的资源库(如果要用到机器学习包，就加上nose、lapack、atlas、numpy、blas、scipy) 123sudo apt-get install build-essentialsudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-devsudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev 二、下载安装包opencv-3.0.0.zip 三、构建OpenCV 解压后进入到文件，然后执行以下命令,如果make install执行出错使用sudo make install,最后完成OpenCV构建 12345mkdir build cd build cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local .. makemake install 四、可能出现的问题 file DOWNLOAD HASH mismatch。hash校验值不符的问题。自行从http://sourceforge.net/projects/opencvlibrary/files/3rdparty/ippicv下载，然后将下载的文件~/opencv-3.0.0/3rdparty/ippicv/downloads/linux-8b449a536a2157bcad08a2b9f266828b ,代替原来的同名文件。 有部分库缺失。在CentOS上安装OpenCV遇到库缺失，尚未找到解决方法。","categories":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://ccxiao5.github.io/categories/OpenCV/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://ccxiao5.github.io/tags/OpenCV/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://ccxiao5.github.io/tags/Ubuntu/"}]},{"title":"openCV 简单实现身高测量（二)","slug":"openCV-简单实现身高测量（二","date":"2019-06-11T08:26:00.000Z","updated":"2021-07-19T09:01:51.019Z","comments":true,"path":"2019/06/11/openCV-简单实现身高测量（二/","link":"","permalink":"https://ccxiao5.github.io/2019/06/11/openCV-%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E8%BA%AB%E9%AB%98%E6%B5%8B%E9%87%8F%EF%BC%88%E4%BA%8C/","excerpt":"","text":"&emsp;&emsp;前篇讲过基于相机焦距和手机PPI进行测量身高，但是这种测量方式具有不可控性，误差很大，所以该篇文章采用参照物对比进行测量身高。 &emsp;&emsp;和前篇一样进行HOG特征检测，Grabcut分割，BorderMatting边缘细化。 然后就是识别参照物，利用直方图均衡化提高对比度然后在进行剔除非阈值范围内的颜色。当然在进行处理之前，将RGB模型转变成HSV模型。该项目是基于小程序实现，所以用户再输入基本信息时需要输入参照物的长度和颜色。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071void GCApplication::measureReferencePX()&#123; Mat imgHSV; //黄、红、蓝 int index; if (color == &quot;黄色&quot;) index = 0; else if (color == &quot;红色&quot;) index = 1; else index = 2; int iLowH[3] = &#123; 18,156,110 &#125;; int iHighH[3] = &#123; 38,180,130 &#125;; //设置饱和度的范围值 int iLowS[3] = &#123; 90,43,43 &#125;; int iHighS = 255; //设置亮度的范围值 int iLowV[3] = &#123; 90,46 ,46 &#125;; int iHighV = 255; vector&lt;Mat&gt; hsvSplit; cvtColor(*image, imgHSV, COLOR_BGR2HSV); //BGR 转化成 HSV，因为直方图均衡化需要在HSV空间做 imshow(&quot;imgHSV1&quot;, imgHSV); split(imgHSV, hsvSplit); equalizeHist(hsvSplit[2], hsvSplit[2]); merge(hsvSplit, imgHSV); inRange(imgHSV, Scalar(iLowH[index], iLowS[index], iLowV[index]), Scalar(iHighH[index], iHighS, iHighV), imgThresholded); //图像的范围 imshow(&quot;Thresholded&quot;, imgThresholded); //开操作 (去除一些噪点) Mat element = getStructuringElement(MORPH_RECT, Size(5, 5)); //morphologyEx(imgThresholded, imgThresholded, MORPH_OPEN, element); //闭操作 (连接一些连通域) morphologyEx(imgThresholded, imgThresholded, MORPH_CLOSE, element); //计算参照物像素高度 int i, j; int flagA, flagB; flagA = flagB = 0; //从上面进行遍历 for (i = 0; i &lt; imgThresholded.rows; i++) &#123; for (j = 0; j &lt; imgThresholded.cols; j++) if (imgThresholded.at&lt;uchar&gt;(i, j) == 255 &amp;&amp; !flagA) // 标记第一个出现像素的像素点 &#123; FA.x = j;//注意顺序，坐标原点位于左上角 FA.y = i; flagA = 1; break; &#125; if (flagA) break; &#125; //从下面进行遍历 for (i = imgThresholded.rows - 1; i &gt; 0; i--) &#123; for (j = 0; j &lt; imgThresholded.cols; j++) if (imgThresholded.at&lt;uchar&gt;(i, j) == 255 &amp;&amp; !flagB) // 标记第一个出现像素的像素点 &#123; FB.x = j;//注意顺序，坐标原点位于左上角 FB.y = i; flagB = 1; break; &#125; if (flagB) break; &#125; imshow(&quot;Thresholded Image&quot;, imgThresholded); maxRefPX = FB.y - FA.y;&#125; 然后也对人物前景进行二值化，遍历找到两组特征点。 计算两个的比例系数K，然后根据参照物真实长度进行等比例计算。 经过系统的测试，如在系统的使用要求下（拍摄距离需2.5m外，测量人员身上携带颜色与参照物颜色不同），误差率在5‰。","categories":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://ccxiao5.github.io/categories/OpenCV/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://ccxiao5.github.io/tags/OpenCV/"},{"name":"c++","slug":"c","permalink":"https://ccxiao5.github.io/tags/c/"}]},{"title":"openCV 简单实现身高测量（未考虑相机标定，windows）","slug":"openCV-简单实现身高测量（未考虑相机标定，windows）","date":"2019-04-28T09:44:00.000Z","updated":"2021-07-19T08:51:14.179Z","comments":true,"path":"2019/04/28/openCV-简单实现身高测量（未考虑相机标定，windows）/","link":"","permalink":"https://ccxiao5.github.io/2019/04/28/openCV-%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E8%BA%AB%E9%AB%98%E6%B5%8B%E9%87%8F%EF%BC%88%E6%9C%AA%E8%80%83%E8%99%91%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A%EF%BC%8Cwindows%EF%BC%89/","excerpt":"","text":"1. OpenCV3.1.0+VS2015开发环境配置 下载OpenCV安装包（笔者下载3.1.0版本）。 环境变量配置。（opencv安装路径\\build\\x64\\vc14\\bin，注意的是x64文件夹下分为vc12和vc14两个文件夹，他们对应于VS的版本，vc8 = Visual Studio 2005，vc9 = Visual Studio 2008，vc10 = Visual Studio 2010，vc11 = Visual Studio 2012，vc12 = Visual Studio 2013，vc14 = Visual Studio 2015） VS2015配置。进入属性管理器（View—&gt;Other Windows—&gt;Property Manger，展开目录，选中Debug|Win64中的Microsoft.Cpp.x64.user，并右键点击属性（Properties）进入属性界面。） 包含目录配置（通用属性（Common Properties）—&gt;VC ++目录—&gt;包含目录（Include Directories））。添加路径：D:\\Code\\C\\opencv\\build\\include；D:\\Code\\C\\opencv\\build\\include\\opencv；D:\\Code\\C\\opencv\\build\\include\\opencv2 配置库文件目录（Library Directories）。D:\\Code\\C\\opencv\\build\\x64\\vc14\\lib（注意VS版本） 配置动态链接库（Linker(链接库)—&gt;Input(输入)—&gt;Additional Dependencies(添加依赖)）。D:\\Code\\C\\opencv\\build\\x64\\vc12\\bin路径下的。opencv_world310.lib和opencv_world310d.lib，这里两个库文件的区别就是：opencv_world310.lib是Release模式版本，而opencv_world310d.lib是Debug模式版本。 2. 算法思路 HOG特征提取获得定位矩形框，笔者使用SVM分类优化+多尺度检测获得带有矩形框的dst 123456789101112131415161718192021222324252627282930313233/******************************HOG detector************************************************/ dst = src.clone(); vector&lt;Rect&gt; findrects, findrect; HOGDescriptor HOG; //SVM分类器 HOG.setSVMDetector(HOGDescriptor::getDefaultPeopleDetector()); //多尺度检测 HOG.detectMultiScale(src, findrects, 0, Size(4, 4), Size(0, 0), 1.05, 2); //若rects有嵌套,则取最外面的矩形存入rect for (int i = 0; i &lt; findrects.size(); i++) &#123; Rect rect = findrects[i]; int j = 0; for (; j &lt; findrects.size(); j++) if (j != i &amp;&amp; (rect &amp; findrects[j]) == rect) break; if (j == findrects.size()) findrect.push_back(rect); &#125; Rect r;//用来选中所测图像中的测量对象。 r.height = -1; //框选出检测结果并选中图片测量对象 for (int i = 0; i &lt; findrect.size(); i++) r = r.height &gt; findrect[i].height ? r : findrect[i]; //HOG detector返回的矩形框比真正图像轮廓大，所以我们减少矩形框的大小来使得更符合外界边框 r.x += cvRound(r.width*0.1); r.width = cvRound(r.width*0.8); r.y += cvRound(r.height*0.07); r.height = cvRound(r.height*0.8); Scalar color = Scalar(0,0,255); rectangle(dst, r.tl(), r.br(), color, 2);// imshow(&quot;src&quot;, src);// imshow(&quot;dst&quot;, dst); 原图像和得到的dst图像 Grabcut算法分割 123456789101112131415161718192021/********************************grabCut**********************************************/ cv::Mat mask = Mat::zeros(src.size(), CV_8UC1);//分割后的结果 //两个临时矩阵变量，作为算法的中间变量使用 cv::Mat bgModel, fgModel; cv::Rect rectangle(r.tl(),r.br());//图像的前景对象也就是矩形选中图像 // GrabCut 分段 cv::grabCut(src, //输入图像 mask, //分段结果 rectangle,// 包含前景的矩形 bgModel, fgModel, // 前景、背景 1, // 迭代次数 cv::GC_INIT_WITH_RECT); // 用矩形 // 得到可能是前景的像素 //比较函数保留值为GC_PR_FGD的像素 cv::compare(mask, cv::GC_PR_FGD, mask, cv::CMP_EQ); // 产生输出图像 cv::Mat foreground(src.size(), CV_8UC3, cv::Scalar(0, 0, 0)); //背景值为 GC_BGD=0，作为掩码 src.copyTo(foreground, mask); imshow(&quot;foreground&quot;, foreground); 处理后的图像 BorderMatting边缘细化处理,主要思想：把前景颜色值与估计值对比，选择较小的差异值颜色代替，使得平滑最好。 1234567891011121314/********************************BorderMatting**********************************************/ BorderMatting bm; Mat rst = Mat(src.size(), src.type()); Mat rstBm; src.copyTo(rst); for (int i = 0; i&lt;rst.rows; i++) for (int j = 0; j &lt; rst.cols; j++) &#123; if (mask.at&lt;uchar&gt;(i, j) == 0) rst.at&lt;Vec3b&gt;(i, j) = Vec3b(255, 255, 255); &#125; bm.Initialize(src, mask); rstBm=bm.Run(); imshow(&quot;bordingmatting&quot;, rstBm); 灰度化、二值化便于计算 1234567/******************************灰度化、二值化************************************************/ Mat rstGray, rstBin; cvtColor(rstBm, rstGray, CV_BGR2GRAY);//灰度化// imshow(&quot;灰度图&quot;, rstGray); threshold(rstGray, rstBin, 100, 255, CV_THRESH_BINARY);//二值化 imshow(&quot;二值图&quot;, rstBin); 最长像素距离计算。笔者一开始用欧氏距离遍历计算得到，结果处理时间过长，就采用最简单的简化方法，最长像素点距离≈最高像素点与最低像素点欧氏距离。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/**********************************计算最长像素距离********************************************/ double MAXPX = 0; int x1 = 0, y1 = 0; int x2 = 0, y2 = 0; int maxX1, maxX2, maxY1, maxY2; int i, j; int flag = 0; for (i = 0; i &lt; rstBin.rows; i++) &#123; for (j = 0; j &lt; rstBin.cols; j++) if (rstBin.at&lt;uchar&gt;(i, j) == 255) &#123; x1 = i; y1 = j; flag = 1; break; &#125; if (flag) break; &#125; flag = 0; for (i = rstBin.rows; i &gt;= 0; i--) &#123; for (j = 0; j &lt; rstBin.cols; j++) if (rstBin.at&lt;uchar&gt;(i, j) == 255) &#123; x2 = i; y2 = j; flag = 1; break; &#125; if (flag) break; &#125; cout &lt;&lt; x1 &lt;&lt; &quot; &quot; &lt;&lt; y1 &lt;&lt; endl; cout &lt;&lt; x2 &lt;&lt; &quot; &quot; &lt;&lt; y2 &lt;&lt; endl; line(src, Point(y1, x1), Point(y2, x2), Scalar(0, 0, 255), 3);/* for ( i = 1; i &lt;= rstBin.rows*rstBin.cols; i++)//第一个像素点开始遍历 &#123; x1 = i / rstBin.rows; y1 = !x1 ? (i - 1) : (i % x1 - 1); if (rstBin.at&lt;uchar&gt;(x1, y1) == 0) continue; for ( j = i + 1; j &lt;= rstBin.rows*rstBin.cols; j++) &#123; x2 = j / rstBin.rows; y2 = !x2 ? (j - 1) : (j % x2 - 1); if (rstBin.at&lt;uchar&gt;(x2, y2) == 255)//同为白色像素点时计算距离 &#123; double distance=abs(x2 - x1) +abs(y2 - y1);//避免欧氏距离计算浪费时间 if (MAXPX &lt; distance) &#123; maxX1 = x1; maxX2 = x2; maxY1 = y1; maxY2 = y2; MAXPX = distance; &#125; &#125; &#125; &#125; */ /*MAXPX = sqrt((maxX1 - maxX2)*(maxX1 - maxX2) + (maxY1 - maxY2)*(maxY1 - maxY2)); cout &lt;&lt; MAXPX &lt;&lt; endl; cout &lt;&lt; maxX1 &lt;&lt; &quot; &quot; &lt;&lt; maxY1 &lt;&lt; endl; cout &lt;&lt; maxX2 &lt;&lt; &quot; &quot; &lt;&lt; maxY2 &lt;&lt; endl; line(src, Point(maxY1, maxX1), Point(maxY2, maxX2), Scalar(0, 0, 255), 3); */imshow(&quot;final&quot;, src); 像素与毫米的转换 转换还需要知道另一个参数： PPI(每英寸多少像素)象素数PPI=英寸数\\dfrac{PPI(每英寸多少像素)象素数}{PPI} = 英寸数 PPIPPI(每英寸多少像素)象素数​=英寸数 英寸数×25.4=毫米数英寸数\\times 25.4 = 毫米数 英寸数×25.4=毫米数 &emsp;&emsp;笔者设定系统参数焦距(3.5mm)不会变动（图为35mm焦距所拍)物距1.1m，ppi：400（笔者电脑PPI260）那么身高大概为： ((790−152)2+(281−247)2)12260×25.435=1.71m\\dfrac{\\dfrac{((790-152)^2+(281-247)^2)^\\dfrac{1}{2}}{260}\\times 25.4}{35}=1.71m 35260((790−152)2+(281−247)2)21​​×25.4​=1.71m","categories":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://ccxiao5.github.io/categories/OpenCV/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://ccxiao5.github.io/tags/OpenCV/"},{"name":"c++","slug":"c","permalink":"https://ccxiao5.github.io/tags/c/"}]},{"title":"php调用c/c++时 passthru()被禁用问题","slug":"php调用c-c-时-passthru-被禁用问题","date":"2019-04-26T07:26:00.000Z","updated":"2021-07-19T07:23:50.794Z","comments":true,"path":"2019/04/26/php调用c-c-时-passthru-被禁用问题/","link":"","permalink":"https://ccxiao5.github.io/2019/04/26/php%E8%B0%83%E7%94%A8c-c-%E6%97%B6-passthru-%E8%A2%AB%E7%A6%81%E7%94%A8%E9%97%AE%E9%A2%98/","excerpt":"","text":"passthru被禁用，需要编辑php.ini文件.去掉passthru，保存并重起php-fpm即可。 1disable_functions = scandir,passthru,exec,system,chroot,chgrp,chown,shell_exec,proc_open,proc_get_status,ini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server,fsocket,fsockopen php.ini 的位置：/usr/local/php/etc/php.ini。最后执行/etc/init.d/php-fpm restart重启下","categories":[{"name":"php","slug":"php","permalink":"https://ccxiao5.github.io/categories/php/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://ccxiao5.github.io/tags/c/"},{"name":"php","slug":"php","permalink":"https://ccxiao5.github.io/tags/php/"}]},{"title":"OpenCV常用头文件","slug":"OpenCV常用头文件","date":"2019-04-17T06:51:00.000Z","updated":"2021-07-19T07:34:58.652Z","comments":true,"path":"2019/04/17/OpenCV常用头文件/","link":"","permalink":"https://ccxiao5.github.io/2019/04/17/OpenCV%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6/","excerpt":"","text":"OpenCV包含的模块 cv – 核心函数库 cvaux – 辅助函数库 cxcore – 数据结构与线性代数库 highgui – GUI函数库 ml – 机器学习函数库 常用头文件 #include &lt;cv.h&gt; #include &lt;cvaux.h&gt; #include &lt;highgui.h&gt; #include &lt;ml.h&gt; #include &lt;cxcore.h&gt; 头文件作用 cxcore.h 基础结构：CvPoint,CvSize,CvScalar 等。 数组操作：cvCreateImage,cvCreateMat 等。 动态结构：CVMemStorage,CvMemBlock 等。 绘图函数：cvLine,cvRectangle 等。 数据保存和运行时类型数据：CvFileStorage,cvOpenFileStorage. 等。 错误处理和系统函数 cvGetErrStatus,cvAlloc,cvFree 等。 ml.h 机器学习模块,基本上是统计模型和分类算法，包含如下内容: 统计模型（Statistical Models） 一般贝叶斯分类器（Normal Bayes Classifier） K-近邻（K-NearestNeighbors） 支持向量机（Support Vector Machines） 决策树（Decision Trees） 提升（Boosting） 梯度提高树（Gradient Boosted Trees） 随机树（Random Trees） 超随机树（Extremely randomized trees） 期望最大化（Expectation Maximization） 神经网络（Neural Networks）MLData cv.h 图像处理函数： cvSobel,cvCanny.等。 结构分析：ContourArea等。 运动分析和目标跟踪:cvMeanShift等。 模式识别：cvHaarFeature等。 摄像头定标与三维重建等。 HighGui 图形界面函数cvNamedWindow等。 图像保存和读取cvLoadImage, cvSaveImage等。 视频读写 CVCreateFileCapture 等。","categories":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://ccxiao5.github.io/categories/OpenCV/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://ccxiao5.github.io/tags/OpenCV/"}]},{"title":"微信小程序中的AJAX——POST，GET区别","slug":"微信小程序中的AJAX——POST，GET区别","date":"2019-04-13T08:43:00.000Z","updated":"2021-07-19T07:34:52.622Z","comments":true,"path":"2019/04/13/微信小程序中的AJAX——POST，GET区别/","link":"","permalink":"https://ccxiao5.github.io/2019/04/13/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84AJAX%E2%80%94%E2%80%94POST%EF%BC%8CGET%E5%8C%BA%E5%88%AB/","excerpt":"","text":"发送服务器时的DATA最终发送给服务器的数据是 String 类型，如果传入的 data 不是 String 类型，会被转换成 String 。转换规则如下： 对于 GET 方法的数据，会将数据转换成 query string(encodeURIComponent(k)=encodeURIComponent(v)&amp;encodeURIComponent(k)=encodeURIComponent(v)...) 对于 POST 方法且 header[‘content-type’] 为 application/json 的数据，会对数据进行 JSON 序列化 对于 POST 方法且 header[‘content-type’] 为 application/x-www-form-urlencoded 的数据，会将数据转换成 query string(encodeURIComponent(k)=encodeURIComponent(v)&amp;encodeURIComponent(k)=encodeURIComponent(v)... 在发送DATA时，要用JSON字符串格式使用JSON对象形式也会出错。例子：data: { value : { “a”:1,“b”:2,“c”:3 } }将会出错，要用JSON.stringify将其字符串化。","categories":[{"name":"小程序","slug":"小程序","permalink":"https://ccxiao5.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://ccxiao5.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"ACM常用STL","slug":"ACM常用STL","date":"2018-03-22T10:04:00.000Z","updated":"2021-07-19T07:34:11.193Z","comments":true,"path":"2018/03/22/ACM常用STL/","link":"","permalink":"https://ccxiao5.github.io/2018/03/22/ACM%E5%B8%B8%E7%94%A8STL/","excerpt":"","text":"stack 12345678910111213141516stack&lt;int&gt;st;//栈st，用于存放int型数据 st.push(3);//将3入栈 st.push(2);//将2入栈 st.pop();//栈顶2出栈 int Top = st.top();//获取栈顶元素,即3 int Size = st.size();//求栈中的元素个数 bool isEmpty = st.empty(); //栈中元素是否为空，1表示空，0表示非空 stack&lt;T&gt;st; // T是存放数据的类型，可以是int, double等，也可以是自定义的结构体类型/**struct Node *&#123; * int x,y; *&#125;; stack&lt;Node&gt; st; */ queue 123456789queue&lt;int&gt;que;//队列que,存放int型数据 que.push(3);//将3入队列 que.push(2);//将2入队列 que.pop();//队首3出队列 int Front = que.front();//获取队首元素 int Size = que.size();//队列中元素个数 bool isEmpty = que.empty(); //是否为空 queue&lt;T&gt;que; // T是存放数据的类型，可以是int, double等，也可以是自定义的结构体类型. priority_queue 优先队列中的元素按照一定的优先级进行排列，对于int型的元素，默认是从大到小进行排列的，队首为最大元素。 123456789101112const int len = 5; int a[len] = &#123;3, 5, 9, 6, 2&#125;; priority_queue&lt;int&gt; q; for(int i = 0; i &lt; len; ++ i) &#123; q.push(a[i]); &#125; for(int i = 0; i &lt; len; ++ i) &#123; cout&lt;&lt; q.top() &lt;&lt;endl; q.pop(); &#125; 输出的元素依次为 9 6 5 3 2 如果要按照从小到大排列，把priority_queue&lt;int&gt;q;这条语句换成priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q;就可以实现。 另外我们可以根据需求，自己定义优先级，对&lt;符号进行重载，使得队列中的元素按照一定的顺序排列，假设我们定义一个操作系统中作业的结构体，里面有两个元素，一个是作业名char name[5]; 一个是到达时间intarriveTime; 把作业对象放到优先队列里面，要求在优先队列按作业到达时间从小到大排列，即到达时间最小的作业在队首. 1234567891011121314151617181920212223242526272829303132struct Job //定义作业结构体 &#123; char name[5];//作业名 int arriveTime;//到达时间 bool operator &lt; (const Job another)const&#123;//如果当前作业到达时间大于另一个，则当前作业优先级小 if(arriveTime &gt; another.arriveTime) return true; return false; &#125; &#125;job[3]; int main() &#123; strcpy(job[0].name, &quot;no1&quot;); strcpy(job[1].name, &quot;no2&quot;); strcpy(job[2].name, &quot;no3&quot;); job[0].arriveTime = 2; job[1].arriveTime = 1; job[2].arriveTime = 3; priority_queue&lt;Job&gt; que; que.push(job[0]); que.push(job[1]); que.push(job[2]); for(int i = 0; i &lt; 3; ++ i) &#123; Job tempJob = que.top(); que.pop(); cout&lt;&lt; tempJob.name &lt;&lt;&quot; &quot;&lt;&lt;tempJob.arriveTime&lt;&lt;endl; &#125; return 0; &#125; 输出为： 12345678910111213141516171819202122232425262728293031no2 1no1 2no3 3``` 实现了优先队列中的作业按照到达时间排序.4. vectorvector是一种容器，可以看做是动态的数组.```cvector&lt;int&gt;vec; vec.push_back(2);//尾部插入数字2,即 vec[0]=2 vec.push_back(4);//尾部插入数字4,即 vec[1]=4 int Size = vec.size();//容器中存放数字的个数 cout&lt;&lt; vec[1] &lt;&lt;endl;//访问第二个数字，即4 for(int i = 0; i &lt; vec.size(); ++ i)//按照下标遍历元素,此时vec[0]=2 vec[1]=4 &#123; cout&lt;&lt; vec[i] &lt;&lt; &quot; &quot;; &#125; cout&lt;&lt;endl; vector&lt;int&gt;::iterator it;//按照迭代器遍历元素 for(it = vec.begin(); it != vec.end(); ++ it) &#123; cout&lt;&lt; *it &lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; vec.insert(vec.begin() + 1, 6);//在第二个位置上插入元素6，即vec[1]=6 vec.erase(vec.begin() + 1);//删除第二个位置上的元素 vec.clear();//把容器中的元素全部清除 另外也可以定义二维动态数组即vector&lt;int&gt;vec[2],也就是两个容器，用它可以很方便的保存有向图的邻接表,即vec[i]中存放的是与第i个顶点相邻的顶点（从顶点i出发），.其操作只要把上述代码中的vec改成vec[i]就可以。 5. set set这种容器里面存放元素是唯一的，即不可能两个相同的数都存在set里面，set的效率比较高，起内部采用了高效的平衡检索二叉树：红黑树。插入的元素按从小到大自动排好序，第一个元素为最小值。 1234567891011121314151617181920212223set&lt;int&gt;st;//容器中存放int型数据 st.insert(2);//插入元素2 st.insert(1); st.insert(3); st.insert(8); int Size = st.size();//容器中元素个数 bool isEmpty = st.empty();//元素是否为空 int has1 = st.count(1);//1这个元素是否在set中 st.count()不是1就是0 int has2 = st.count(6);//6这个元素是否在set中，has1值为1 has2值为0 st.erase(1);//在容器中删除1这个元素 bool inSet = (st.find(-2)!= st.end());//-2这个元素是否在set中 cout&lt;&lt;*st.lower_bound(1)&lt;&lt;endl;//返回set中第一个大于等于1的数 cout&lt;&lt;*st.upper_bound(1)&lt;&lt;endl;//返回set中第一个大于1的数 set&lt;int&gt;:: iterator it;//遍历set容器，输出 1 2 3 for(it = st.begin(); it != st.end(); ++ it) &#123; cout&lt;&lt; *it &lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; st.clear();//清空set中的元素 map map是一种映射关系，一对一，第一个为关键字（first），第二个为键值(second)，关键字唯一，map中的元素按关键字有序. 实际应用中要考虑好关键字和键值代表的意义，灵活运用。 12345678910111213141516map&lt;string, int&gt; mp; //关键字为string类型，键值为int 类型，我们可以用来表示某一个符 //串str出现的次数,int型键值默认为0 cout&lt;&lt; mp[“hello”] &lt;&lt;endl; //输出”hello”这个字符串出现的次数，这里原来map是空的，但 //但是我们输出了一下以后，mp的元素个数自动变成了1，但是”hello”对应的键值仍然为0 mp.clear();//清空元素 mp.insert(make_pair(&quot;hello&quot;,1));//插入键值对，代表初始的时候&quot;hello&quot;出现的次数为1 mp.insert(make_pair(&quot;world&quot;,3));//插入键值对，初始的时候&quot;world&quot;出现的次数为3 mp.insert(make_pair(&quot;apple&quot;,1));//插入键值对，初始的时候&quot;apple”出现的次数为1 cout&lt;&lt;mp.size()&lt;&lt;endl;//map中的元素个数，这里输出3 map&lt;string, int&gt;:: iterator it;//遍历map for(it = mp.begin(); it!= mp.end(); ++ it) &#123; cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl; &#125; 输出如下： 123apple 1hello 1world 3 可以发现元素是按关键字从小到大排好序的。 1234567891011121314cout&lt;&lt; mp[“hello”]&lt;&lt;end;//查看”hello”出现的次数 mp[“hello”] ++ ;//”hello”出现的次数+1 bool inMap = mp.count(“hello”); //”hello”是否在map中，返回0或1 inMap = (mp.find(&quot;hello&quot;) != mp.end()); //”hello”是否在map中，返回0或1 for(it = mp.begin(); it != mp.end(); ++ it)//查找到”hello”,然后删除该元素 &#123; if(it-&gt;first == &quot;hello&quot;) &#123; mp.erase(it); break; &#125; &#125; sort 头文件#include 使用sort可以很方便的对数组进行进行排序,它可以传两个或三个参数。第一个参数是要排序的区间首地址，第二个参数是区间尾地址的下一个地址，也就是排序的区间为[a,b),比如有一个数组 int a[5], 使得a[0] 到a[4]从小到大有序，只要写 sort(a, a + 5)就可以了，通用sort(a, a+ n);// n为元素个数。sort内部采用的是快速排序，一般情况下效率很高. 12345const int n = 3; int arr[n] = &#123;1, 3, 2&#125;; sort(arr,arr+n); for(int i = 0; i &lt; n; ++ i) cout&lt;&lt; arr[i] &lt;&lt;endl; 另外，我们也可以按照自己的需求进行元素排序，元素可以是结构体，这里就用到了第三个参数，比较函数，告诉计算机按照什么顺序进行排序。 比如：按照从大到小排序 1234567891011121314151617181920212223242526272829bool cmp(int a, int b)//定义比较函数，从大到小 &#123; if(a &gt;= b) return true; return false; &#125;``` 主函数中： sort(arr, arr+n,cmp); 再比如下面结构体，要按照学生的年龄从小到大排序.```cstruct Student &#123; int age; //年龄 string name;//姓名 &#125;student[3]; bool cmp(Student a, Student b) &#123; if(a.age &lt;= b.age) return true; return false; &#125; student[0].name = &quot;aa&quot;;student[0].age = 15; student[1].name = &quot;bb&quot;;student[1].age = 10; student[2].name = &quot;cc&quot;;student[2].age = 8; sort(student, student+3, cmp); for(int i = 0; i &lt; 3; ++ i) cout&lt;&lt; student[i].name &lt;&lt;&quot; &quot;&lt;&lt;student[i].age&lt;&lt;endl; 输出： 123cc 8bb 10aa 15 cmath 123cout&lt;&lt; log2(8) &lt;&lt;endl; //输出3 , 因为2的3次方为8 cout&lt;&lt; log10(100) &lt;&lt;endl; //输出2，因为10的2次方为100 cout&lt;&lt; log(20) &lt;&lt;endl; //计算 ln(20)的值 补充： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126//vector----------------- vector&lt;int&gt;v; v.erase(v.begin() + 2);//删除第2个元素，从0开始计数 v.erase(v.begin() + 1, v.begin() + 5);//删除第1到第5个元素 sort(v.begin(), v.end());//元素排序 //sort(v.begin(), v.end(), cmp);//自定义排序规则，cmp函数自定义 reverse(v.begin(), v.end()); //string----------------- string s; s = &quot;123456&quot;; string::iterator it; it = s.begin(); s.insert(it + 1, &#x27;p&#x27;);// s 变为 1p23456 s.erase(it + 3);//删除第3个字符，从0开始计数 s = &quot;abc123456&quot;; s.replace(3, 3, &quot;good&quot;);//从第3个开始，将连续的3个字符替换为&quot;good&quot;,即将123替换为good reverse(s.begin(), s.end()); //set-------------------- set&lt;int&gt;st; //反向遍历，从大到小 set&lt;int&gt;::reverse_iterator rit;//定义反向迭代器 for(rit = st.rbegin(); rit != st.rend(); rit ++) &#123; cout &lt;&lt; *rit &lt;&lt; endl; &#125; //multiset--------------里面值可以重复 multiset&lt;int&gt; ms; int n = ms.erase(3); //删除里面所有的3，返回删除元素总个数 multiset&lt;int&gt;::iterator it; it = ms.find(3); if(it != ms.end())//找到了3这个元素 &#123; cout &lt;&lt; *it &lt;&lt;endl; &#125; else &#123; cout&lt;&lt; &quot;not find it&quot;&lt;&lt;endl; &#125; //map-----------键值--&gt;映照数据 map&lt;int&gt; mp; mp.erase(2);//删除键值为2的元素 map&lt;int&gt;::iterator it; it = mp.find(2);//查找键值 if(it != mp.end())//找到了 &#123; cout &lt;&lt; (*it).first &lt;&lt; (*it).second &lt;&lt;endl; &#125; struct Info &#123; string name; float score; //重载&#x27;&lt;&#x27;操作符，自定义排序规则，在map中 bool operator &lt; (const Info &amp;a) const &#123; //按score从小到大排序 return a.score &lt; score; &#125; &#125;; map&lt;Info, int&gt; mmp; //multimap------------允许键值相同的存在 multimap&lt;string, double&gt;m; m.insert(pair&lt;string, double&gt; (&quot;jack&quot;, 20.4)); m.insert(pair&lt;string, double&gt; (&quot;jack&quot;, 34.1)); m.erase(&quot;jack&quot;);//删除键值等于&quot;jack&quot;的元素 //find()函数只返回重复键值中的第一个元素的迭代器位置 //deque-------------双端队列 push_back()方法在尾部插入元素，不断扩张队列 push_front()和insert()在首部和中间位置插入元素，只是将原位置上的元素值覆盖，不会增加新元素 deque&lt;int&gt; d; d.push_back(1); d.push_back(2); d.push_back(3); d.insert(d.begin() + 1, 88); cout &lt;&lt; d[0] &lt;&lt; d[1] &lt;&lt; d[2] &lt;&lt;endl; //输出 1 88 3 d.pop_front();//头部删除元素 d.pop_back();//尾部删除元素 d.erase(d.begin() + 1); //list--------------链表 list&lt;int&gt; l; l.push_back(2); l.push_back(1); l.push_back(5);//链表尾部插入元素，链表自动扩张 l.push_front(8);//链表头部插入元素，链表自动扩张 list&lt;int&gt;::iterator it; it = l.begin(); it ++;//注意链表的迭代器只能进行 ++ 或者 -- ，不能 + n l.insert(it, 20); for(it = l.begin(); it != l.end(); it ++) &#123; cout &lt;&lt; *it &lt;&lt;endl; //输出 8 20 2 1 5 &#125; l.remove(2);//值为2的节点都删除 l.pop_front();//删除首部元素 l.pop_back();//删除尾部元素 l.sort();//排序 l.unique();//剔除重复元素， 3 8 1 1 1 3 1 ----&gt; 3 8 1 3 1 //bitset 位集合容器 bitset&lt;10&gt;b; //能容纳10个元素，也就是10位，默认都为0 //赋值 b[1] = 1; b[6] = 1; b[9] = 1; //第0位是最低位，第9位是最高位 for(int i = b.size() - 1; i &gt;= 0; i --) &#123; cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;; //输出 1001000010 &#125; b.set();//全部重置为1 b.set(1, 1);//将第1位置为1 b.set(6, 1); b.set(9, 1); b.reset(9);//将第9位置为0 cout &lt;&lt; b &lt;&lt;endl;// 和上面效果相同，也是输出1001000010","categories":[{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/categories/C/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://ccxiao5.github.io/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://ccxiao5.github.io/tags/STL/"}]},{"title":"STL中的二分查找","slug":"STL中的二分查找","date":"2018-03-22T09:55:00.000Z","updated":"2021-07-19T07:33:56.660Z","comments":true,"path":"2018/03/22/STL中的二分查找/","link":"","permalink":"https://ccxiao5.github.io/2018/03/22/STL%E4%B8%AD%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"使用的时候注意：必须用在非递减的区间中 二分查找的原理非常简单，但写出的代码中很容易含有很多Bug，二分查找一文中讲解过如何实现不同类型的二分查找，但是否一定要自己去实现二分查找呢？答案显然是否定的，本文将讲解STL中与二分查找有关函数的具体使用方法及其实现原理。 函数使用 STL中与二分查找相关的函数有4个，分别是lower_bound, upper_bound, equal_range和binary_search，下面通过一个简单的例子说明各个函数的使用方法。 其中每个函数实现的功能如下： binary_search：查找某个元素是否出现。 lower_bound：查找第一个大于或等于某个元素的位置。 upper_bound：查找第一个大于某个元素的位置。 equal_range：查找某个元素出现的起止位置。注意，终止位置为最后一次出现的位置加一。 binary_search试图在已排序的[first, last)中寻找元素value。如果[first, last)内有等价于value的元素，它会返回true，否则返回false，它不返回查找位置。 lower_bound它试图在已排序的[first,last)中寻找元素value。如果[first, last)具有等价于value的元素，lower_bound返回一个iterator指向其中第一个元素。如果没有这样的元素存在，它便返回假设这样的元素存在的话，会出现的位置。即指向第一个不小于value的元素。如果value大于[first, last)的任何一个元素，则返回last。 upper_bound它试图在已排序的[first,last)中寻找value，返回可安插value的最后一个合适的位置。如果value存在，lower_bound 返回的是指向该元素的iterator。相较之下upper_bound并不这么做，它返回value可被安插的最后一个合适位置。如果value存在，那么它返回的iterator将指向value的下一个位置，而非value自身。 equal_range的返回值本质上结合了lower_bound和upper_bound两者的返回值。其返回值是一对iterator i和j ,其中i是value可安插的第一个位置，j则是value可安插的最后一个位置。可以推演出：[i，j)中的每个元素都等价于value，而且[i, j)是[first, last)之中符合上述性质的一个最大子区间。 算法lower_bound返回该range的第一个iterator， 算法upper_bound返回该range的past-the-end iterator，算法equal_range则是以pair的形式将两者都返回。 STL 中的 lower_bound()， 函数lower_bound()在first和last中的前闭后开区间进行二分查找，返回大于或等于val的第一个元素位置。如果所有元素都小于val，则返回last的位置 举例如下： 一个数组number序列为：4,10,11,30,69,70,96,100.设要插入数字3,9,111.pos为要插入的位置的下标 则 pos = lower_bound( number, number + 8, 3) - number，pos = 0.即number数组的下标为0的位置。 pos = lower_bound( number, number + 8, 9) - number， pos = 1，即number数组的下标为1的位置（即10所在的位置）。 pos = lower_bound( number, number + 8, 111) - number， pos = 8，即number数组的下标为8的位置（但下标上限为7，所以返回最后一个元素的下一个元素）。 所以，要记住：函数lower_bound()在first和last中的前闭后开区间进行二分查找，返回大于或等于val的第一个元素位置。如果所有元素都小于val，则返回last的位置，且last的位置是越界的！！ 12345678910111213141516171819#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;string&gt; #include &lt;iostream&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; int main() &#123; int point[10] = &#123;1,3,7,7,9&#125;; int tmp = upper_bound(point, point + 5, 7)- point;//按从小到大，7最多能插入数组point的哪个位置 printf(&quot;%d\\n&quot;,tmp); tmp = lower_bound(point, point + 5, 7) - point;////按从小到大，7最少能插入数组point的哪个位置 printf(&quot;%d\\n&quot;,tmp); return 0; &#125;","categories":[{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/categories/C/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://ccxiao5.github.io/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://ccxiao5.github.io/tags/STL/"}]},{"title":"STL--set","slug":"STL-set","date":"2018-03-22T09:46:00.000Z","updated":"2021-07-19T07:33:43.959Z","comments":true,"path":"2018/03/22/STL-set/","link":"","permalink":"https://ccxiao5.github.io/2018/03/22/STL-set/","excerpt":"","text":"set集合容器：实现了红黑树的平衡二叉检索树的数据结构，插入元素时，它会自动调整二叉树的排列，把元素放到适当的位置，以保证每个子树根节点键值大于左子树所有节点的键值，小于右子树所有节点的键值；另外，还得保证根节点左子树的高度与右子树高度相等。 平衡二叉检索树使用中序遍历算法，检索效率高于vector、deque和list等容器，另外使用中序遍历可将键值按照从小到大遍历出来。 构造set集合主要目的是为了快速检索，不可直接去修改键值.并且set容器中有去重的效果 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;set&lt;int&gt; s;set&lt;int&gt;::iterator it;int main()&#123; s.insert(4); s.insert(2); s.insert(1); s.insert(3); s.insert(5); s.insert(1); for(it = s.begin(); it != s.end(); it++) cout&lt;&lt;*it&lt;&lt;&quot; &quot;; cout&lt;&lt;endl&lt;&lt;s.size()&lt;&lt;endl;; it = s.end(); s.erase(4); for(it = s.begin(); it != s.end(); it++) cout&lt;&lt;*it&lt;&lt;&quot; &quot;; cout&lt;&lt;endl&lt;&lt;*s.find(1)&lt;&lt;endl; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/categories/C/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://ccxiao5.github.io/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://ccxiao5.github.io/tags/STL/"}]},{"title":"STL总结","slug":"STL总结","date":"2018-03-22T09:23:00.000Z","updated":"2021-07-19T07:33:27.796Z","comments":true,"path":"2018/03/22/STL总结/","link":"","permalink":"https://ccxiao5.github.io/2018/03/22/STL%E6%80%BB%E7%BB%93/","excerpt":"","text":"见：http://www.cnblogs.com/biyeymyhjob/archive/2012/07/22/2603525.html","categories":[{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/categories/C/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://ccxiao5.github.io/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://ccxiao5.github.io/tags/STL/"}]},{"title":"STL--set_difference","slug":"STL-set-difference","date":"2018-03-22T09:20:00.000Z","updated":"2021-07-19T07:33:07.106Z","comments":true,"path":"2018/03/22/STL-set-difference/","link":"","permalink":"https://ccxiao5.github.io/2018/03/22/STL-set-difference/","excerpt":"","text":"set_difference（），作用是求两个集合的差。即求A-B(属于A但不属于B的元素) set_difference()算法计算两个集合[start1, end1)和[start2, end2)的差集, 并将差集存放到result. 两个集合以序列的形式给出, 且必须先按升序排好位置. set_difference()是一个指向result序列末尾的迭代器. 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int a[100],b[100];int main()&#123; int n,m; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) &#123; if(n == 0 &amp;&amp; m == 0) break; int i; for(i = 0;i &lt; n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(i = 0;i &lt; m;i++) scanf(&quot;%d&quot;,&amp;b[i]); sort(a,a + n); sort(b,b + m); vector&lt;int&gt; v(100); vector&lt;int&gt;::iterator it; it = set_difference(a,a + n,b,b + m,v.begin()); v.resize(it-v.begin()); if(v.size() == 0) cout&lt;&lt;&quot;NULL&quot;&lt;&lt;endl; else &#123; for(it = v.begin(); it != v.end(); it++) cout&lt;&lt;*it&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; &#125; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/categories/C/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://ccxiao5.github.io/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://ccxiao5.github.io/tags/STL/"}]},{"title":"priority_queue和sort应用","slug":"priority-queue和sort应用","date":"2018-03-21T05:23:00.000Z","updated":"2021-07-19T07:32:49.969Z","comments":true,"path":"2018/03/21/priority-queue和sort应用/","link":"","permalink":"https://ccxiao5.github.io/2018/03/21/priority-queue%E5%92%8Csort%E5%BA%94%E7%94%A8/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243#include&quot;iostream&quot;#include&quot;String&quot;#include&quot;stdio.h&quot;#include &quot;string.h&quot;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;class Number&#123; public: int a; bool operator &lt;(const Number &amp;m) const&#123; return a &gt; m.a; &#125;&#125;;priority_queue&lt;Number&gt; q;bool compare(int a,int b)&#123; return a &gt; b;//如果是&gt;就是从大到小，是&lt;就是从小到大&#125;int main()&#123; Number num[5]; num[0].a = 3; num[1].a = 5; num[2].a = 2; num[3].a = 9; num[4].a = 1; int i; for(i = 0;i &lt; 5;i++) q.push(num[i]); while(!q.empty()) &#123; cout&lt;&lt;q.top().a&lt;&lt;&quot;\\t&quot;; q.pop(); &#125; cout&lt;&lt;endl; int a[5] = &#123;3,5,2,9,1&#125;; sort(a,a+5,compare); for(i = 0 ;i &lt; 5; i++) cout&lt;&lt;a[i]&lt;&lt;&quot;\\t&quot;;&#125; 结果如下","categories":[{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/categories/C/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://ccxiao5.github.io/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://ccxiao5.github.io/tags/STL/"}]},{"title":"16进制转化8进制---map","slug":"16进制转化8进制-map","date":"2018-03-14T05:44:00.000Z","updated":"2021-07-19T07:32:36.893Z","comments":true,"path":"2018/03/14/16进制转化8进制-map/","link":"","permalink":"https://ccxiao5.github.io/2018/03/14/16%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8C%968%E8%BF%9B%E5%88%B6-map/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &quot;stdio.h&quot;#include &quot;string.h&quot;#include &quot;string&quot;#include &quot;iostream&quot;#include &quot;math.h&quot;#include &quot;map&quot;#include &quot;queue&quot;#include &quot;malloc.h&quot;using namespace std;map&lt;char,string&gt; mp;int main()&#123; mp[&#x27;0&#x27;]=&quot;0000&quot;;mp[&#x27;1&#x27;]=&quot;0001&quot;;mp[&#x27;2&#x27;]=&quot;0010&quot;;mp[&#x27;3&#x27;]=&quot;0011&quot;;mp[&#x27;4&#x27;]=&quot;0100&quot;; mp[&#x27;5&#x27;]=&quot;0101&quot;;mp[&#x27;6&#x27;]=&quot;0110&quot;;mp[&#x27;7&#x27;]=&quot;0111&quot;;mp[&#x27;8&#x27;]=&quot;1000&quot;;mp[&#x27;9&#x27;]=&quot;1001&quot;; mp[&#x27;A&#x27;]=&quot;1010&quot;;mp[&#x27;B&#x27;]=&quot;1011&quot;;mp[&#x27;C&#x27;]=&quot;1100&quot;;mp[&#x27;D&#x27;]=&quot;1101&quot;;mp[&#x27;E&#x27;]=&quot;1110&quot;; mp[&#x27;F&#x27;]=&quot;1111&quot;; int a; char test[100005]; cin &gt;&gt; a; while(a--) &#123; memset(test,0,sizeof(test)); string b=&quot;&quot;; cin&gt;&gt;test; for(int i = 0;i &lt; strlen(test);i++) &#123; b += mp[test[i]]; &#125; int len = b.length(); if(len%3==1) b = &quot;00&quot; + b; else if(len%3==2) b = &quot;0&quot; + b; int flag = 0; for(int i = 0 ;i &lt; b.length(); i = i + 3) &#123; int num = 4*(b[i]-&#x27;0&#x27;)+2*(b[i+1]-&#x27;0&#x27;)+(b[i+2]-&#x27;0&#x27;); if(num) flag = 1; if(flag) cout&lt;&lt;num; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 但是这个跑在蓝桥杯的题目中会超时，因为map查询是对数时间复杂度放在循环中会超时 更改map后通过 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &quot;stdio.h&quot;#include &quot;string.h&quot;#include &quot;string&quot;#include &quot;iostream&quot;#include &quot;math.h&quot;#include &quot;map&quot;#include &quot;queue&quot;using namespace std;map&lt;char,string&gt; mp;int main()&#123; int a; string test; cin &gt;&gt; a; while(a--) &#123; string b=&quot;&quot;; cin&gt;&gt;test; for(int i=0;i&lt;test.length();i++)//遍历，字符串上加上每一位 &#123; switch(test[i]) &#123; case &#x27;0&#x27;:b+=&quot;0000&quot;;break; case &#x27;1&#x27;:b+=&quot;0001&quot;;break; case &#x27;2&#x27;:b+=&quot;0010&quot;;break; case &#x27;3&#x27;:b+=&quot;0011&quot;;break; case &#x27;4&#x27;:b+=&quot;0100&quot;;break; case &#x27;5&#x27;:b+=&quot;0101&quot;;break; case &#x27;6&#x27;:b+=&quot;0110&quot;;break; case &#x27;7&#x27;:b+=&quot;0111&quot;;break; case &#x27;8&#x27;:b+=&quot;1000&quot;;break; case &#x27;9&#x27;:b+=&quot;1001&quot;;break; case &#x27;A&#x27;:b+=&quot;1010&quot;;break; case &#x27;B&#x27;:b+=&quot;1011&quot;;break; case &#x27;C&#x27;:b+=&quot;1100&quot;;break; case &#x27;D&#x27;:b+=&quot;1101&quot;;break; case &#x27;E&#x27;:b+=&quot;1110&quot;;break; case &#x27;F&#x27;:b+=&quot;1111&quot;;break; default:break; &#125; &#125; int len = b.length(); if(len%3==1) b = &quot;00&quot; + b; else if(len%3==2) b = &quot;0&quot; + b; int flag = 0; for(int i = 0 ;i &lt; b.length(); i = i + 3) &#123; int num = 4*(b[i]-&#x27;0&#x27;)+2*(b[i+1]-&#x27;0&#x27;)+(b[i+2]-&#x27;0&#x27;); if(num) flag = 1; if(flag) cout&lt;&lt;num; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/categories/C/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://ccxiao5.github.io/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://ccxiao5.github.io/tags/STL/"}]},{"title":"C++ Map遍历","slug":"C-Map遍历","date":"2018-03-12T13:21:00.000Z","updated":"2021-07-19T07:32:15.728Z","comments":true,"path":"2018/03/12/C-Map遍历/","link":"","permalink":"https://ccxiao5.github.io/2018/03/12/C-Map%E9%81%8D%E5%8E%86/","excerpt":"","text":"1234567891011121314151617181920#include &quot;stdio.h&quot;#include &quot;string.h&quot;#include &quot;string&quot;#include &quot;iostream&quot;#include &quot;math.h&quot;#include &quot;map&quot;using namespace std;map&lt;char,string&gt; mp;map&lt;char,string&gt;::iterator it;int main(int argc, char const *argv[])&#123; mp[&#x27;0&#x27;]=&quot;0000&quot;;mp[&#x27;1&#x27;]=&quot;0001&quot;;mp[&#x27;2&#x27;]=&quot;0010&quot;;mp[&#x27;3&#x27;]=&quot;0011&quot;; mp[&#x27;4&#x27;]=&quot;0100&quot;;mp[&#x27;5&#x27;]=&quot;0101&quot;;mp[&#x27;6&#x27;]=&quot;0110&quot;;mp[&#x27;7&#x27;]=&quot;0111&quot;; mp[&#x27;8&#x27;]=&quot;1000&quot;;mp[&#x27;9&#x27;]=&quot;1001&quot;;mp[&#x27;A&#x27;]=&quot;1010&quot;;mp[&#x27;B&#x27;]=&quot;1011&quot;; mp[&#x27;C&#x27;]=&quot;1100&quot;;mp[&#x27;D&#x27;]=&quot;1101&quot;;mp[&#x27;E&#x27;]=&quot;1110&quot;;mp[&#x27;F&#x27;]=&quot;1111&quot;; for(it = mp.begin(); it != mp.end(); it++) //it-&gt;first下标的值，it-&gt;second所在下标的值 cout&lt;&lt;it-&gt;first&lt;&lt;&quot;:&quot;&lt;&lt;it-&gt;second&lt;&lt;endl; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/categories/C/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://ccxiao5.github.io/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://ccxiao5.github.io/tags/STL/"}]},{"title":"requirejs的使用和快速理解","slug":"requirejs的使用和快速理解","date":"2018-01-23T12:12:00.000Z","updated":"2021-07-19T07:27:39.104Z","comments":true,"path":"2018/01/23/requirejs的使用和快速理解/","link":"","permalink":"https://ccxiao5.github.io/2018/01/23/requirejs%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3/","excerpt":"","text":"requirejs有以下功能 声明不同js文件之间的依赖 可以按需、并行、延时载入js库 可以让我们的代码以模块化的方式组织 初看起来并不复杂。 创建以下目录 在HTML中，添加&lt;script&gt;标签：&lt;script data-main=&quot;js/script/main&quot; src=&quot;js/lib/require.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Require Demo 1&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h1&gt;Require Demo 1 -- usage of Require()&lt;/h1&gt; &lt;button id=&quot;contentBtn&quot;&gt;Click me&lt;/button&gt; &lt;p id=&quot;messagebox&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;script data-main=&quot;js/script/main&quot; src=&quot;js/lib/require.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; requirejs对外暴露的变量其实就三个,requirejs,require,define。这其中requirejs 只是require的一个别名，目的是如果页面中有require其它实现了，你还是能通过使用requirejs来使用requireJS API的(本文中没有相关冲突，所以还是使用require)。 我们可以看到在script标签中我们加载了require.js，其中有一个data-main，他是在require.js加载完成后通过回调的方法去加载data-main里的js 这是我们的main.js 12345678910111213141516171819202122232425262728// js/script/main.js require.config( &#123; paths: &#123;//一个模块ID和路径的映射，这样在后续的所有函数中就可以直接通过模块ID来引入依赖，而不用再多次引入依赖多次输入路径带来的麻烦。 jquery: &#x27;../lib/jquery-1.11.1&#x27;, chw_desc:&#x27;desc&#x27;, chw_alertdesc:&#x27;alertdesc&#x27;, chw_alert:&#x27;alert&#x27; &#125;, // shim:&#123; // &#x27;alert&#x27;: &#123;exports: &#x27;f&#x27;&#125; // &#125; &#125; ); require([&#x27;jquery&#x27;],function ($) &#123; $(document).on(&#x27;click&#x27;,&#x27;#contentBtn&#x27;,function()&#123; $(&#x27;#messagebox&#x27;).html(&#x27;You have access Jquery by using require()&#x27;); require([&#x27;desc&#x27;],function(chw)&#123; alert(&#x27;desc: &#x27;+JSON.stringify(chw)); &#125;); // require([&#x27;chw_alertdesc&#x27;],function(t)&#123; // alert(&#x27;alertdest: &#x27;+JSON.stringify(t)); // &#125;); // require([&#x27;alert&#x27;],function(chw)&#123; // chw(); // &#125;); &#125;); &#125;); 首先看最基础的decs.js（没有任何依赖） 他的require函数接受的第一个参数是所依赖模块的一个数组，即要想执行我的回调函数，你必须加载完desc.js这个文件，如果你有如本例子中设置了模块ID和路径的映射，那你在传入依赖的时候就可以使用模块ID来代替路径（我可以换成require([‘chw_desc’],function(chw){})），如果没有配置模块ID你当然也可以通过路径来引进对应的模块。接着是传入回调函数，当引入的依赖加载完毕后，这个回调函数就会被触发。如果你传入的依赖有注入变量（函数）,然后在回调函数中需要用到，你就需要按照顺序在回调函数的参数中添加别名，在本例子中可以通过别名$来使用jQuery的相关API(你也可以换成其他的符号比如‘G’,'F’等等)。 看看desc.js代码，没有任何依赖，desc.js他定义了一个模块，define(name, deps, callback)第一个参数是定义模块名，第二个参数是传入定义模块所需要的依赖，第三个函数则是定义模块的主函数，主函数和require的回调函数一样，同样是在依赖加载完以后再调用执行。第一参数不是很必要，因为如果哪一天我将这个文件转移到其他目录下，那我就得在这这里再修改一次模块名。 12345define(function()&#123; return&#123; desc:&#x27;this js will be request only if it is needed&#x27;, &#125;;&#125; 在看看alertdesc,js(依赖于desc.js) 12345define([&#x27;desc&#x27;],function()&#123; return&#123; desc:&#x27;this js will be request only if it is needed&#x27;, &#125;;&#125;) 同样在require函数里面可以写成 require([‘alertdesc’],function(t){}) alert.js. (加载非规范的模块没使用define定义模块) 123function f() &#123; alert(&quot;hahah&quot;);&#125; require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性，他就是将某个依赖中的某个全局变量暴露给requirejs，当作这个模块本身的引用。 123shim:&#123; &#x27;alert&#x27;: &#123;exports: &#x27;f&#x27;&#125; &#125; 由于我这个模块没有依赖，所以没必要写deps，上面的代码表示的是在’alert’（在相对路径下的alert.js文件中），把f函数暴露出来成为全局可用，那当我们的代码依赖于 alert 模块的时候，就可以拿到这个 f 函数的引用了。注意的是require(['alert'],function(chw)&#123;&#125;&#125;);不能换成require(['chw_alert'],function(chw)&#123;&#125;&#125;);因为在你暴露变量的时候你是暴露给模块名为’alert’，所以对于其他的模块并不是全局可用，如果要换成chw_alert，那么shim中应该这样写shim:{‘chw_alert’:{exports:‘f’}}","categories":[{"name":"web","slug":"web","permalink":"https://ccxiao5.github.io/categories/web/"}],"tags":[{"name":"requirejs","slug":"requirejs","permalink":"https://ccxiao5.github.io/tags/requirejs/"}]},{"title":"Bootstrap滚动监视原理实现","slug":"Bootstrap滚动监视原理实现","date":"2018-01-19T09:58:00.000Z","updated":"2021-07-19T07:27:13.747Z","comments":true,"path":"2018/01/19/Bootstrap滚动监视原理实现/","link":"","permalink":"https://ccxiao5.github.io/2018/01/19/Bootstrap%E6%BB%9A%E5%8A%A8%E7%9B%91%E8%A7%86%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"最近在公司实习，刚好写了一个静态的网页，用到了滚动监视，就自己写了个监视，话不多说直接进入正题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151$(function () &#123; var $root = $(&quot;html,body&quot;); var location = [];//存储item active属性状态 true表示有class=&quot;active&quot; location[&quot;position_1&quot;] = false; location[&quot;position_2&quot;] = false; location[&quot;position_3&quot;] = false; location[&quot;position_4&quot;] = false; location[&quot;position_5&quot;] = false; location[&quot;position_6&quot;] = false; location[&quot;position_7&quot;] = false; var offset1,offset2,offset3, offset4,offset5,offset6,offset7; //各个锚点的距离顶部的偏移 offset1 = $(&quot;[name = position_1]&quot;).offset().top - 2 * parseInt($(&quot;.header_top&quot;).css(&quot;height&quot;).toString().split(&quot;px&quot;)[0]); offset2 = $(&quot;[name = position_2]&quot;).offset().top - 2 * parseInt($(&quot;.header_top&quot;).css(&quot;height&quot;).toString().split(&quot;px&quot;)[0]); offset3 = $(&quot;[name = position_3]&quot;).offset().top - 2 * parseInt($(&quot;.header_top&quot;).css(&quot;height&quot;).toString().split(&quot;px&quot;)[0]); offset4 = $(&quot;[name = position_4]&quot;).offset().top - 2 * parseInt($(&quot;.header_top&quot;).css(&quot;height&quot;).toString().split(&quot;px&quot;)[0]); offset5 = $(&quot;[name = position_5]&quot;).offset().top - 2 * parseInt($(&quot;.header_top&quot;).css(&quot;height&quot;).toString().split(&quot;px&quot;)[0]); offset6 = $(&quot;[name = position_6]&quot;).offset().top - 2 * parseInt($(&quot;.header_top&quot;).css(&quot;height&quot;).toString().split(&quot;px&quot;)[0]); offset7 = offset6 + parseInt($(&quot;#section_6&quot;).css(&quot;height&quot;).toString().split(&quot;px&quot;)[0]) / 2;//最后部分高度不够，不能按部就班，否则滚动条到不到指定位置就倒底了 function initi () &#123; for(var i in location) location[i] = false; &#125; // debugger; $(window).scroll(function () &#123; // debugger; var Scroll = $(document).scrollTop(); $(&quot;[class = &#x27;active&#x27;]&quot;).removeAttr(&quot;class&quot;); if(Scroll &lt; offset2 &amp;&amp; Scroll &gt;= offset1) &#123; initi(); $(&quot;[href =#position_1]&quot;).parent().attr(&quot;class&quot;, &quot;active&quot;); location[&quot;position_1&quot;] = true; &#125; else if(Scroll &lt; offset3 &amp;&amp; Scroll &gt;= offset2) &#123; initi(); $(&quot;[href =#position_2]&quot;).parent().attr(&quot;class&quot;,&quot;active&quot;); location[&quot;position_2&quot;] = true; &#125; else if(Scroll &lt; offset4 &amp;&amp; Scroll &gt;= offset3)&#123; initi(); $(&quot;[href =#position_3]&quot;).parent().attr(&quot;class&quot;,&quot;active&quot;); location[&quot;position_3&quot;] = true; &#125; else if(Scroll &lt; offset5 &amp;&amp; Scroll &gt;= offset4) &#123; initi(); $(&quot;[href =#position_4]&quot;).parent().attr(&quot;class&quot;, &quot;active&quot;); location[&quot;position_4&quot;] = true; &#125; else if(Scroll &lt; offset6 &amp;&amp; Scroll &gt;= offset5) &#123; initi(); $(&quot;[href =#position_5]&quot;).parent().attr(&quot;class&quot;, &quot;active&quot;); location[&quot;position_5&quot;] = true; &#125; else if(Scroll &lt; offset7 &amp;&amp; Scroll &gt;= offset6)&#123; initi(); $(&quot;[href =#position_6]&quot;).parent().attr(&quot;class&quot;, &quot;active&quot;); location[&quot;position_6&quot;] = true; &#125; else &#123; initi(); $(&quot;[href =#position_7]&quot;).parent().attr(&quot;class&quot;, &quot;active&quot;); location[&quot;position_7&quot;] = true; &#125; &#125;); $(&quot;a&quot;).on(&quot;click&quot;,function (e) &#123; var event = e || window.event; var son = $(event.target); var father = son.parent(); var Name = father.prop(&quot;tagName&quot;); if(Name == &quot;LI&quot;) &#123; var act = $(&quot;[class =&#x27;active&#x27;]&quot;).children(&quot;a&quot;).attr(&quot;href&quot;).toString().split(&quot;#&quot;)[1]; location[act] = false; $(&quot;[class =&#x27;active&#x27;]&quot;).removeAttr(&quot;class&quot;); var pos = son.attr(&quot;href&quot;).toString().split(&quot;#&quot;)[1]; location[pos] = true; $root.animate(&#123; scrollTop: $(&quot;[name=\\&quot;&quot; + pos + &quot;\\&quot;]&quot;).offset().top &#125;, 1000); father.attr(&quot;class&quot;, &quot;active&quot;); return false; &#125; else if(Name == &quot;A&quot;) &#123; var flag = false,pri,real,next,total = 0; var temp,num_next = 0,num_pri = 0; for(var i in location) &#123; if(location[i]) &#123; flag = true; break; &#125; &#125; if(flag == false) &#123; location[&quot;position_1&quot;] = true; window.location.href = &quot;#position_1&quot;; &#125; for (i in location) &#123; total++; if (location[i]) &#123; temp = i.split(&quot;_&quot;); num_next = parseInt(temp[1]) + 1; num_pri = parseInt(temp[1]) - 1; if(total == 1) &#123; pri = real = i; next = temp[0] + &quot;_&quot; + num_next; &#125; else if(total == 7) &#123; next = real = i; pri = temp[0] + &quot;_&quot; + num_pri; &#125; else &#123; next = temp[0] + &quot;_&quot; + num_next; real = i; pri = temp[0] + &quot;_&quot; + num_pri; &#125; break; &#125; &#125; if(son.hasClass(&quot;prev&quot;)) &#123; location[real] = false; location[pri] = true; $root.animate(&#123; scrollTop: $(&quot;[name=\\&quot;&quot; + pri + &quot;\\&quot;]&quot;).offset().top &#125;, 1000); $(&quot;[class =&#x27;active&#x27;]&quot;).removeAttr(&quot;class&quot;); $(&quot;[href=\\&quot;#&quot; + pri + &quot;\\&quot;]&quot;).parent().attr(&quot;class&quot;,&quot;active&quot;); return false; &#125; else if(son.hasClass(&quot;next&quot;)) &#123; location[real] = false; location[next] = true; $root.animate(&#123; scrollTop: $(&quot;[name=\\&quot;&quot; + next + &quot;\\&quot;]&quot;).offset().top &#125;, 1000); $(&quot;[class=&#x27;active&#x27;]&quot;).removeAttr(&quot;class&quot;); $(&quot;[href=\\&quot;#&quot; + next + &quot;\\&quot;]&quot;).parent().attr(&quot;class&quot;,&quot;active&quot;); return false; &#125; else return false; &#125; &#125;);&#125;); 在实习的时候做页面出现的几个问题 1.图片自适应浏览器窗口完全显示 查看图片的长宽 设置所在图片div的padding-top为高/宽 比如，一张图片是 2000*1333 那么设置所在div padding-top:66.65%; 在div里面放空的block标签强行撑开 然后在div中设置background: url(&quot;…/picture/bg.jpg&quot;) no-repeat;background-size: cover; 2.滚动监视的时候发生的锚点偏移问题，过了锚点，还没触发了事件 这种情况是因为头部设置了一个固定位置的div，从而导致这个div就不占空间了，他下面的元素就填充他的位置。 解决不占空间的方法：1.设置margin-top 2.设置一个空div 解决锚点偏移的方法：设置暗锚来填充形成的固定位置的div 1234567&lt;div id=&quot;section_2&quot; class=&quot;container&quot;&gt; &lt;a name=&quot;position_2&quot; class=&quot;target-fix&quot;&gt;&lt;/a&gt; &lt;h1&gt;信息15-1&lt;/h1&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt; &lt;p&gt;To be or not to be,that&#x27;s a question.&lt;br/&gt;&lt;br/&gt; 决心不过是记忆的奴隶 它会根据你的记忆随意更改(When sorrows come, they come not single spies, - but in battalions.)&lt;br/&gt;&lt;br/&gt; &lt;/p&gt; &lt;/div&gt; 123456.target-fix&#123; display: block; position: relative; top: -65px;&#125; 比如说我的固定位置的div高度是65px，那么我这个暗锚就上移65px，然后我就只用跳转到这个锚点位置就行&lt;li&gt;&lt;a href=&quot;#position_2&quot;&gt;信息15-1&lt;/a&gt;&lt;/li&gt; 原理：虽然元素被fixed在最上面了，可是页面计算section_2的页边距报读的时候还是把fixed的高度算上去了，所以点击锚点链接的时候，偏移的距离是section_2页边距的高度加上fixed的高度(section_2.offset().top + nav.height)所以设置暗锚向上偏移65px; 因为写的是静态页面 写的很随意把页面写死了 css文件里出现的多余的样式是因为我直接把实习的工程文件截取抽过来，所以代码就很难看了~~~~~~想要看看效果的就自行查看百度云链接：https://pan.baidu.com/s/1kWDK8rP 密码：6de2","categories":[{"name":"web","slug":"web","permalink":"https://ccxiao5.github.io/categories/web/"}],"tags":[{"name":"bootstrap","slug":"bootstrap","permalink":"https://ccxiao5.github.io/tags/bootstrap/"},{"name":"javascript","slug":"javascript","permalink":"https://ccxiao5.github.io/tags/javascript/"}]},{"title":"Bootstrap模态框原理分析及问题解决","slug":"Bootstrap模态框原理分析及问题解决","date":"2018-01-19T07:07:00.000Z","updated":"2021-07-19T07:25:11.034Z","comments":true,"path":"2018/01/19/Bootstrap模态框原理分析及问题解决/","link":"","permalink":"https://ccxiao5.github.io/2018/01/19/Bootstrap%E6%A8%A1%E6%80%81%E6%A1%86%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","excerpt":"","text":"最近自学了bootstrap觉得里面模板样式挺好的，就想自己实现实现，不多说了，开始进入正题了 今天就来实现bootstrap里面的模态框弹出效果 首先很简单 实现一个类似于panel的modal 1234567891011121314151617181920&lt;body&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; style=&quot;display: block;margin: 20px auto;&quot;&gt;Click me!&lt;/button&gt;&lt;div class=&quot;chw-dialog&quot;&gt; &lt;div class=&quot;chw-modal&quot;&gt; &lt;div class=&quot;chw-title&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot;&gt; &lt;span&gt;×&lt;/span&gt; &lt;/button&gt; &lt;h4&gt;chw-Modal title&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;chw-content&quot;&gt; &lt;p&gt;fantasy baby&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;chw-footer&quot;&gt; &lt;button class=&quot;btn btn-info&quot;&gt;Save changes&lt;/button&gt; &lt;button class=&quot;btn btn-default&quot;&gt;Close&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556.chw-dialog &#123; display: none; position: fixed; top:0; right: 0; bottom: 0; left: 0; z-index: 1100; opacity: 0; transition : opacity .15s linear; &#125; .chw-modal&#123; width: 600px; margin: 30px auto; box-shadow: 0 5px 10px rgba(0,0,0,.5); border-radius: 6px; border: 1px solid rgba(0,0,0,.5); z-index: 1200; background-color: white; transform: translate(0,-25%); transition: transform 0.3s ease-out; &#125; .chw-panel&#123; position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 1024; background-color: black; opacity: 0; transition : opacity .15s linear; &#125; .chw-title&#123; padding:15px; border-bottom: 1px solid #dddddd; &#125; .chw-title h4&#123; line-height: 1.4; font-size: 23px; margin: 0; &#125; .chw-content&#123; padding:15px; border-bottom: 1px solid #dddddd; &#125; .chw-footer&#123; padding: 15px; clear: both; overflow: hidden; &#125; .chw-footer button&#123; float: right; margin-right: 10px; &#125; &lt;/style&gt; 好了不多说开始重点部分，先看看bootstrap的源代码，点击button后 发现有一个后面有一个蒙层 看见myModa和其子元素都没有background-color和opacity结合使用的，说明这个蒙层不是myModal生成的，那这个蒙层是怎么生成的？ 我把myModal的类全部删除后(剔除css样式)发现蒙层还在，从而更加确信了我的猜测，然后用chrome去获取蒙层发现这个蒙层在整个html最下面。 那为什么一开始没有索取到这个元素能，因为z-index的效果 这个蒙层div(z-index:1040;)在modal类的下面(z-index:1050;)退出后，这个蒙层div就没有了，说明通过js添加 好了在清楚大体css结构的时候我们自己来写一个类似的弹出功能点击按钮，js生成蒙层你的modal点击周围或者退出按钮时蒙层删除modal隐藏。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;script&gt; $(&quot;body&gt;button&quot;).on(&#x27;click&#x27;,function () &#123; var temp = &quot;&lt;div class=&#x27;chw-panel&#x27;&gt;&lt;/div&gt;&quot;; $(&quot;body&quot;).append(temp); $(&quot;.chw-dialog&quot;).css(&quot;display&quot;,&quot;block&quot;); setTimeout(function()&#123;//后续会说明setTimeout $(&quot;.chw-panel&quot;).css(&quot;opacity&quot;,&quot;0.5&quot;); $(&quot;.chw-dialog&quot;).css(&quot;opacity&quot;,&quot;1&quot;); $(&quot;.chw-modal&quot;).css( &quot;transform&quot;,&quot;translate(0,0)&quot;); &#125;,1); &#125;); $(&#x27;.chw-dialog&#x27;).on(&#x27;click&#x27;,function()&#123; debugger; $(&quot;.chw-panel&quot;).css(&quot;opacity&quot;,&quot;0&quot;); $(&quot;.chw-dialog&quot;).css(&quot;opacity&quot;,&quot;0&quot;); $(&quot;.chw-modal&quot;).css( &quot;transform&quot;,&quot;translate(0,-25%)&quot;); setTimeout(function () &#123; $(&quot;.chw-dialog&quot;).hide(); $(&quot;.chw-panel&quot;).remove(); &#125;,1); &#125;); $(&quot;.chw-modal&quot;).click(function (e) &#123; e.stopPropagation(); return false; &#125;); $(&quot;.close&quot;).click(function () &#123; $(&quot;.chw-panel&quot;).css(&quot;opacity&quot;,&quot;0&quot;); $(&quot;.chw-dialog&quot;).css(&quot;opacity&quot;,&quot;0&quot;); $(&quot;.chw-modal&quot;).css( &quot;transform&quot;,&quot;translate(0,-25%)&quot;); setTimeout(function () &#123; $(&quot;.chw-dialog&quot;).hide(); $(&quot;.chw-panel&quot;).remove(); &#125;,1); &#125;);&lt;/script&gt;``` 首先我是先完成大概功能即点击按钮显示然后退出没有考虑动画，在实现的时候发现了几个问题： &lt;b&gt;1.点击按钮后生成蒙层没有问题，但是点击modal以外部分没有退出，没有任何反应。(这个问题是因为在实现蒙层的点击生成退出的时候发现的，但实际上是点击chw-dialog来关闭的因为他的z-index高于那个蒙层div的z-index)&lt;/b&gt; &amp;emsp;&lt;b&gt;解决方法：使用$.on()，jquery版本1.7+&lt;/b&gt; &amp;emsp;&lt;font color=&quot;red&quot;&gt;因为我原来写的函数是`$(&#x27;.chw-panel&#x27;).click(function()&#123;&#125;)`无论怎么点击那个蒙层也不会触发函数，查阅资料后发现&lt;/font&gt;，我们在给动态添加的标签绑定事件的时候(给通过append添加过来的标签`&lt;span class=”test”&gt;&lt;/span&gt;`),不能直接写$(‘.test’).click(function()&#123;&#125;);是因为jquery他的事件机制是当页面完全加载成功后，会根据所有目前页面上符合要求的dom添加事件标示，这样当你触发事件的时候，拥有该事件标示的DOM就会给予响应。但append很可能是页面加载完成后，再触发的事件，这样的话，初始化的时候就没有成功加上，所以你不能简单的使用click,需要用on。由于事件的&lt;font color=&quot;red&quot;&gt;冒泡机制&lt;/font&gt;(如果子事件没有完成(没有定义子事件的处理函数)或者事件返回true，那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理(父级对象所有同类事件都将被激活)，或者它到达了对象层次的最顶层，即document对象(有些浏览器是window)举个例子我有个子事件没有被处理，那么他会传递到他的父级看看父级是否能解决，如果不能继续向上级传递直到解决为止)$(“body”).on(‘click’,’.test’,function()&#123;&#125;);这个表明是body这个对象绑定事件，如果body的子元素.test的div触发了点击事件，因为.test没有绑定事件(通过append添加的div)，那么他要向上传递，当传递到body的时候，body通过jquery知道是哪个子元素触发了函数，如果这个子元素刚好和自己选择的元素一致的话就执行函数。如果这样写`$(“body”).on(‘click’,function()&#123;&#125;)`;表明只要他的子元素触发事件都会执行函数，就像点击了body触发函数一样，然而实际是子元素触发事件传递到body执行函数。&lt;b&gt;2.无论点击哪个地方都会退出&lt;/b&gt; &amp;emsp;&lt;b&gt;解决方法：使用stopPropagation()&lt;/b&gt; &amp;emsp;如果我没有加红色的那段代码时，发现点击按钮后，无论我点击哪个地方都会退出，这和我们的预期不一样啊，他应该是点击modal以外的部分退出。怎么会出现这样的情况呢？因为我的.chw-modal是.chw-dialog的子元素，在定义事件触发函数的时候是这样写的$(&#x27;.chw-dialog&#x27;).on(&#x27;click&#x27;,function()&#123;&#125;);由于事件的冒泡机制，无论你点击.chw-dialog的任何子元素，在这些子元素没有绑定函数的前提下，你的子元素都会执行.chw-dialog绑定的函数在实现弹出退出后，添加延迟来实现动画过度```css.chw-dialog &#123; display: none; position: fixed; top:0; right: 0; bottom: 0; left: 0; z-index: 1100; opacity: 0; transition : opacity .15s linear;&#125;.chw-modal&#123; width: 600px; margin: 30px auto; box-shadow: 0 5px 10px rgba(0,0,0,.5); border-radius: 6px; border: 1px solid rgba(0,0,0,.5); z-index: 1200; background-color: white; transform: translate(0,-25%);//初始div位置 transition: transform 0.3s ease-out;&#125;.chw-panel&#123; position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 1024; background-color: black; opacity: 0; transition : opacity .15s linear;&#125; 在初始化位置和定义相应的transition后，接下来就是通过js添加css来触发动画，改变css的时候发现了一个问题，改变css后但是动画没有出现失效了，这是为什么呢？经过自己测试: ` $(\"button\").click(function(){$(\".test\").css(\"opacity\",\"1\");}); ` 发现可以实现动画效果，那为什么myModal的动画效果没有出来呢，经过查阅资料发现，如果在css中先执行了让display:none;变成block的操作的时候动画不会出现，原因是因为在js中语句几乎是同时执行，所以要想他们之间有个前后运行的效果 有两种办法 1.使用setTimeout来控制css属性值变化 2.使用animate在回调函数里面设置display(不能和transition同时使用) 解决了以上问题后就能做到类似的弹出效果啦是不是很炫~~~~~上面需要引用bootstrap.css","categories":[{"name":"web","slug":"web","permalink":"https://ccxiao5.github.io/categories/web/"}],"tags":[{"name":"bootstrap","slug":"bootstrap","permalink":"https://ccxiao5.github.io/tags/bootstrap/"}]}],"categories":[{"name":"python","slug":"python","permalink":"https://ccxiao5.github.io/categories/python/"},{"name":"树莓派","slug":"树莓派","permalink":"https://ccxiao5.github.io/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://ccxiao5.github.io/categories/OpenCV/"},{"name":"php","slug":"php","permalink":"https://ccxiao5.github.io/categories/php/"},{"name":"小程序","slug":"小程序","permalink":"https://ccxiao5.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/categories/C/"},{"name":"web","slug":"web","permalink":"https://ccxiao5.github.io/categories/web/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ccxiao5.github.io/tags/python/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://ccxiao5.github.io/tags/OpenCV/"},{"name":"c++","slug":"c","permalink":"https://ccxiao5.github.io/tags/c/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://ccxiao5.github.io/tags/Ubuntu/"},{"name":"php","slug":"php","permalink":"https://ccxiao5.github.io/tags/php/"},{"name":"小程序","slug":"小程序","permalink":"https://ccxiao5.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"ACM","slug":"ACM","permalink":"https://ccxiao5.github.io/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://ccxiao5.github.io/tags/STL/"},{"name":"requirejs","slug":"requirejs","permalink":"https://ccxiao5.github.io/tags/requirejs/"},{"name":"bootstrap","slug":"bootstrap","permalink":"https://ccxiao5.github.io/tags/bootstrap/"},{"name":"javascript","slug":"javascript","permalink":"https://ccxiao5.github.io/tags/javascript/"}]}