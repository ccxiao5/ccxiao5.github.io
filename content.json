{"meta":{"title":"Xiao5's Blog","subtitle":"","description":"","author":"Tigerwcheng","url":"https://ccxiao5.github.io","root":"/"},"pages":[{"title":"书单|Books","date":"2021-07-16T03:02:32.469Z","updated":"2021-07-16T03:02:32.469Z","comments":false,"path":"books/index.html","permalink":"https://ccxiao5.github.io/books/index.html","excerpt":"","text":"推荐书单：《7470》 《4740》 《情商》 《地位》 《格局》 PS：在我人生最迷茫的时候，正是这些书籍的陪伴让我走出困境，在此推荐给大家。"},{"title":"关于|About","date":"2021-07-16T02:53:44.121Z","updated":"2021-07-16T02:53:44.121Z","comments":false,"path":"about/index.html","permalink":"https://ccxiao5.github.io/about/index.html","excerpt":"","text":"我来自湖北广水，目前于北京交通大学攻读全日制学术型硕士。"},{"title":"标签|tags","date":"2021-07-16T02:55:24.343Z","updated":"2021-07-16T02:55:24.343Z","comments":false,"path":"tags/index.html","permalink":"https://ccxiao5.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类|categories","date":"2021-07-16T03:20:38.787Z","updated":"2021-07-16T03:20:38.787Z","comments":false,"path":"categories/index.html","permalink":"https://ccxiao5.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"微信小程序开发---自定义组件","slug":"微信小程序开发-自定义组件","date":"2021-07-16T06:09:11.000Z","updated":"2021-07-16T06:09:11.172Z","comments":true,"path":"2021/07/16/微信小程序开发-自定义组件/","link":"","permalink":"https://ccxiao5.github.io/2021/07/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"微信小程序开发---视图层(View)","slug":"微信小程序开发-视图层-View","date":"2021-07-16T06:08:57.000Z","updated":"2021-07-16T06:08:57.330Z","comments":true,"path":"2021/07/16/微信小程序开发-视图层-View/","link":"","permalink":"https://ccxiao5.github.io/2021/07/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91-%E8%A7%86%E5%9B%BE%E5%B1%82-View/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"微信小程序开发---逻辑层(App Service)","slug":"微信小程序开发-逻辑层-App-Service","date":"2021-07-16T06:08:38.000Z","updated":"2021-07-16T06:08:38.189Z","comments":true,"path":"2021/07/16/微信小程序开发-逻辑层-App-Service/","link":"","permalink":"https://ccxiao5.github.io/2021/07/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91-%E9%80%BB%E8%BE%91%E5%B1%82-App-Service/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"微信小程序开发---各代码文件简介","slug":"微信小程序开发-各代码文件简介","date":"2021-07-16T06:08:10.000Z","updated":"2021-07-16T06:08:10.094Z","comments":true,"path":"2021/07/16/微信小程序开发-各代码文件简介/","link":"","permalink":"https://ccxiao5.github.io/2021/07/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91-%E5%90%84%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6%E7%AE%80%E4%BB%8B/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"微信小程序开发----微信开发者工具使用","slug":"微信小程序开发-微信开发者工具使用","date":"2021-07-16T06:07:56.000Z","updated":"2021-07-16T06:07:56.688Z","comments":true,"path":"2021/07/16/微信小程序开发-微信开发者工具使用/","link":"","permalink":"https://ccxiao5.github.io/2021/07/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91-%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"ACM常用STL","slug":"ACM常用STL","date":"2021-07-16T06:07:26.000Z","updated":"2021-07-16T07:51:05.738Z","comments":true,"path":"2021/07/16/ACM常用STL/","link":"","permalink":"https://ccxiao5.github.io/2021/07/16/ACM%E5%B8%B8%E7%94%A8STL/","excerpt":"","text":"stack 12345678910111213141516stack&lt;int&gt;st;//栈st，用于存放int型数据 st.push(3);//将3入栈 st.push(2);//将2入栈 st.pop();//栈顶2出栈 int Top = st.top();//获取栈顶元素,即3 int Size = st.size();//求栈中的元素个数 bool isEmpty = st.empty(); //栈中元素是否为空，1表示空，0表示非空 stack&lt;T&gt;st; // T是存放数据的类型，可以是int, double等，也可以是自定义的结构体类型/**struct Node *&#123; * int x,y; *&#125;; stack&lt;Node&gt; st; */ queue 123456789queue&lt;int&gt;que;//队列que,存放int型数据 que.push(3);//将3入队列 que.push(2);//将2入队列 que.pop();//队首3出队列 int Front = que.front();//获取队首元素 int Size = que.size();//队列中元素个数 bool isEmpty = que.empty(); //是否为空 queue&lt;T&gt;que; // T是存放数据的类型，可以是int, double等，也可以是自定义的结构体类型. priority_queue 优先队列中的元素按照一定的优先级进行排列，对于int型的元素，默认是从大到小进行排列的，队首为最大元素。 123456789101112const int len = 5; int a[len] = &#123;3, 5, 9, 6, 2&#125;; priority_queue&lt;int&gt; q; for(int i = 0; i &lt; len; ++ i) &#123; q.push(a[i]); &#125; for(int i = 0; i &lt; len; ++ i) &#123; cout&lt;&lt; q.top() &lt;&lt;endl; q.pop(); &#125; 输出的元素依次为 9 6 5 3 2 如果要按照从小到大排列，把priority_queue&lt;int&gt;q;这条语句换成priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q;就可以实现。 另外我们可以根据需求，自己定义优先级，对&lt;符号进行重载，使得队列中的元素按照一定的顺序排列，假设我们定义一个操作系统中作业的结构体，里面有两个元素，一个是作业名char name[5]; 一个是到达时间intarriveTime; 把作业对象放到优先队列里面，要求在优先队列按作业到达时间从小到大排列，即到达时间最小的作业在队首. 1234567891011121314151617181920212223242526272829303132struct Job //定义作业结构体 &#123; char name[5];//作业名 int arriveTime;//到达时间 bool operator &lt; (const Job another)const&#123;//如果当前作业到达时间大于另一个，则当前作业优先级小 if(arriveTime &gt; another.arriveTime) return true; return false; &#125; &#125;job[3]; int main() &#123; strcpy(job[0].name, &quot;no1&quot;); strcpy(job[1].name, &quot;no2&quot;); strcpy(job[2].name, &quot;no3&quot;); job[0].arriveTime = 2; job[1].arriveTime = 1; job[2].arriveTime = 3; priority_queue&lt;Job&gt; que; que.push(job[0]); que.push(job[1]); que.push(job[2]); for(int i = 0; i &lt; 3; ++ i) &#123; Job tempJob = que.top(); que.pop(); cout&lt;&lt; tempJob.name &lt;&lt;&quot; &quot;&lt;&lt;tempJob.arriveTime&lt;&lt;endl; &#125; return 0; &#125; 输出为： 12345678910111213141516171819202122232425262728293031no2 1no1 2no3 3``` 实现了优先队列中的作业按照到达时间排序.4. vectorvector是一种容器，可以看做是动态的数组.```cvector&lt;int&gt;vec; vec.push_back(2);//尾部插入数字2,即 vec[0]=2 vec.push_back(4);//尾部插入数字4,即 vec[1]=4 int Size = vec.size();//容器中存放数字的个数 cout&lt;&lt; vec[1] &lt;&lt;endl;//访问第二个数字，即4 for(int i = 0; i &lt; vec.size(); ++ i)//按照下标遍历元素,此时vec[0]=2 vec[1]=4 &#123; cout&lt;&lt; vec[i] &lt;&lt; &quot; &quot;; &#125; cout&lt;&lt;endl; vector&lt;int&gt;::iterator it;//按照迭代器遍历元素 for(it = vec.begin(); it != vec.end(); ++ it) &#123; cout&lt;&lt; *it &lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; vec.insert(vec.begin() + 1, 6);//在第二个位置上插入元素6，即vec[1]=6 vec.erase(vec.begin() + 1);//删除第二个位置上的元素 vec.clear();//把容器中的元素全部清除 另外也可以定义二维动态数组即vector&lt;int&gt;vec[2],也就是两个容器，用它可以很方便的保存有向图的邻接表,即vec[i]中存放的是与第i个顶点相邻的顶点（从顶点i出发），.其操作只要把上述代码中的vec改成vec[i]就可以。 5. set set这种容器里面存放元素是唯一的，即不可能两个相同的数都存在set里面，set的效率比较高，起内部采用了高效的平衡检索二叉树：红黑树。插入的元素按从小到大自动排好序，第一个元素为最小值。 1234567891011121314151617181920212223set&lt;int&gt;st;//容器中存放int型数据 st.insert(2);//插入元素2 st.insert(1); st.insert(3); st.insert(8); int Size = st.size();//容器中元素个数 bool isEmpty = st.empty();//元素是否为空 int has1 = st.count(1);//1这个元素是否在set中 st.count()不是1就是0 int has2 = st.count(6);//6这个元素是否在set中，has1值为1 has2值为0 st.erase(1);//在容器中删除1这个元素 bool inSet = (st.find(-2)!= st.end());//-2这个元素是否在set中 cout&lt;&lt;*st.lower_bound(1)&lt;&lt;endl;//返回set中第一个大于等于1的数 cout&lt;&lt;*st.upper_bound(1)&lt;&lt;endl;//返回set中第一个大于1的数 set&lt;int&gt;:: iterator it;//遍历set容器，输出 1 2 3 for(it = st.begin(); it != st.end(); ++ it) &#123; cout&lt;&lt; *it &lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; st.clear();//清空set中的元素 map map是一种映射关系，一对一，第一个为关键字（first），第二个为键值(second)，关键字唯一，map中的元素按关键字有序. 实际应用中要考虑好关键字和键值代表的意义，灵活运用。 12345678910111213141516map&lt;string, int&gt; mp; //关键字为string类型，键值为int 类型，我们可以用来表示某一个符 //串str出现的次数,int型键值默认为0 cout&lt;&lt; mp[“hello”] &lt;&lt;endl; //输出”hello”这个字符串出现的次数，这里原来map是空的，但 //但是我们输出了一下以后，mp的元素个数自动变成了1，但是”hello”对应的键值仍然为0 mp.clear();//清空元素 mp.insert(make_pair(&quot;hello&quot;,1));//插入键值对，代表初始的时候&quot;hello&quot;出现的次数为1 mp.insert(make_pair(&quot;world&quot;,3));//插入键值对，初始的时候&quot;world&quot;出现的次数为3 mp.insert(make_pair(&quot;apple&quot;,1));//插入键值对，初始的时候&quot;apple”出现的次数为1 cout&lt;&lt;mp.size()&lt;&lt;endl;//map中的元素个数，这里输出3 map&lt;string, int&gt;:: iterator it;//遍历map for(it = mp.begin(); it!= mp.end(); ++ it) &#123; cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl; &#125; 输出如下： 123apple 1hello 1world 3 可以发现元素是按关键字从小到大排好序的。 1234567891011121314cout&lt;&lt; mp[“hello”]&lt;&lt;end;//查看”hello”出现的次数 mp[“hello”] ++ ;//”hello”出现的次数+1 bool inMap = mp.count(“hello”); //”hello”是否在map中，返回0或1 inMap = (mp.find(&quot;hello&quot;) != mp.end()); //”hello”是否在map中，返回0或1 for(it = mp.begin(); it != mp.end(); ++ it)//查找到”hello”,然后删除该元素 &#123; if(it-&gt;first == &quot;hello&quot;) &#123; mp.erase(it); break; &#125; &#125; sort 头文件#include 使用sort可以很方便的对数组进行进行排序,它可以传两个或三个参数。第一个参数是要排序的区间首地址，第二个参数是区间尾地址的下一个地址，也就是排序的区间为[a,b),比如有一个数组 int a[5], 使得a[0] 到a[4]从小到大有序，只要写 sort(a, a + 5)就可以了，通用sort(a, a+ n);// n为元素个数。sort内部采用的是快速排序，一般情况下效率很高. 12345const int n = 3; int arr[n] = &#123;1, 3, 2&#125;; sort(arr,arr+n); for(int i = 0; i &lt; n; ++ i) cout&lt;&lt; arr[i] &lt;&lt;endl; 另外，我们也可以按照自己的需求进行元素排序，元素可以是结构体，这里就用到了第三个参数，比较函数，告诉计算机按照什么顺序进行排序。 比如：按照从大到小排序 1234567891011121314151617181920212223242526272829bool cmp(int a, int b)//定义比较函数，从大到小 &#123; if(a &gt;= b) return true; return false; &#125;``` 主函数中： sort(arr, arr+n,cmp); 再比如下面结构体，要按照学生的年龄从小到大排序.```cstruct Student &#123; int age; //年龄 string name;//姓名 &#125;student[3]; bool cmp(Student a, Student b) &#123; if(a.age &lt;= b.age) return true; return false; &#125; student[0].name = &quot;aa&quot;;student[0].age = 15; student[1].name = &quot;bb&quot;;student[1].age = 10; student[2].name = &quot;cc&quot;;student[2].age = 8; sort(student, student+3, cmp); for(int i = 0; i &lt; 3; ++ i) cout&lt;&lt; student[i].name &lt;&lt;&quot; &quot;&lt;&lt;student[i].age&lt;&lt;endl; 输出： 123cc 8bb 10aa 15 cmath 123cout&lt;&lt; log2(8) &lt;&lt;endl; //输出3 , 因为2的3次方为8 cout&lt;&lt; log10(100) &lt;&lt;endl; //输出2，因为10的2次方为100 cout&lt;&lt; log(20) &lt;&lt;endl; //计算 ln(20)的值 补充： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126//vector----------------- vector&lt;int&gt;v; v.erase(v.begin() + 2);//删除第2个元素，从0开始计数 v.erase(v.begin() + 1, v.begin() + 5);//删除第1到第5个元素 sort(v.begin(), v.end());//元素排序 //sort(v.begin(), v.end(), cmp);//自定义排序规则，cmp函数自定义 reverse(v.begin(), v.end()); //string----------------- string s; s = &quot;123456&quot;; string::iterator it; it = s.begin(); s.insert(it + 1, &#x27;p&#x27;);// s 变为 1p23456 s.erase(it + 3);//删除第3个字符，从0开始计数 s = &quot;abc123456&quot;; s.replace(3, 3, &quot;good&quot;);//从第3个开始，将连续的3个字符替换为&quot;good&quot;,即将123替换为good reverse(s.begin(), s.end()); //set-------------------- set&lt;int&gt;st; //反向遍历，从大到小 set&lt;int&gt;::reverse_iterator rit;//定义反向迭代器 for(rit = st.rbegin(); rit != st.rend(); rit ++) &#123; cout &lt;&lt; *rit &lt;&lt; endl; &#125; //multiset--------------里面值可以重复 multiset&lt;int&gt; ms; int n = ms.erase(3); //删除里面所有的3，返回删除元素总个数 multiset&lt;int&gt;::iterator it; it = ms.find(3); if(it != ms.end())//找到了3这个元素 &#123; cout &lt;&lt; *it &lt;&lt;endl; &#125; else &#123; cout&lt;&lt; &quot;not find it&quot;&lt;&lt;endl; &#125; //map-----------键值--&gt;映照数据 map&lt;int&gt; mp; mp.erase(2);//删除键值为2的元素 map&lt;int&gt;::iterator it; it = mp.find(2);//查找键值 if(it != mp.end())//找到了 &#123; cout &lt;&lt; (*it).first &lt;&lt; (*it).second &lt;&lt;endl; &#125; struct Info &#123; string name; float score; //重载&#x27;&lt;&#x27;操作符，自定义排序规则，在map中 bool operator &lt; (const Info &amp;a) const &#123; //按score从小到大排序 return a.score &lt; score; &#125; &#125;; map&lt;Info, int&gt; mmp; //multimap------------允许键值相同的存在 multimap&lt;string, double&gt;m; m.insert(pair&lt;string, double&gt; (&quot;jack&quot;, 20.4)); m.insert(pair&lt;string, double&gt; (&quot;jack&quot;, 34.1)); m.erase(&quot;jack&quot;);//删除键值等于&quot;jack&quot;的元素 //find()函数只返回重复键值中的第一个元素的迭代器位置 //deque-------------双端队列 push_back()方法在尾部插入元素，不断扩张队列 push_front()和insert()在首部和中间位置插入元素，只是将原位置上的元素值覆盖，不会增加新元素 deque&lt;int&gt; d; d.push_back(1); d.push_back(2); d.push_back(3); d.insert(d.begin() + 1, 88); cout &lt;&lt; d[0] &lt;&lt; d[1] &lt;&lt; d[2] &lt;&lt;endl; //输出 1 88 3 d.pop_front();//头部删除元素 d.pop_back();//尾部删除元素 d.erase(d.begin() + 1); //list--------------链表 list&lt;int&gt; l; l.push_back(2); l.push_back(1); l.push_back(5);//链表尾部插入元素，链表自动扩张 l.push_front(8);//链表头部插入元素，链表自动扩张 list&lt;int&gt;::iterator it; it = l.begin(); it ++;//注意链表的迭代器只能进行 ++ 或者 -- ，不能 + n l.insert(it, 20); for(it = l.begin(); it != l.end(); it ++) &#123; cout &lt;&lt; *it &lt;&lt;endl; //输出 8 20 2 1 5 &#125; l.remove(2);//值为2的节点都删除 l.pop_front();//删除首部元素 l.pop_back();//删除尾部元素 l.sort();//排序 l.unique();//剔除重复元素， 3 8 1 1 1 3 1 ----&gt; 3 8 1 3 1 //bitset 位集合容器 bitset&lt;10&gt;b; //能容纳10个元素，也就是10位，默认都为0 //赋值 b[1] = 1; b[6] = 1; b[9] = 1; //第0位是最低位，第9位是最高位 for(int i = b.size() - 1; i &gt;= 0; i --) &#123; cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;; //输出 1001000010 &#125; b.set();//全部重置为1 b.set(1, 1);//将第1位置为1 b.set(6, 1); b.set(9, 1); b.reset(9);//将第9位置为0 cout &lt;&lt; b &lt;&lt;endl;// 和上面效果相同，也是输出1001000010","categories":[{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/categories/C/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://ccxiao5.github.io/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://ccxiao5.github.io/tags/STL/"}]},{"title":"STL中的二分查找","slug":"STL中的二分查找","date":"2021-07-16T06:07:09.000Z","updated":"2021-07-16T07:34:08.749Z","comments":true,"path":"2021/07/16/STL中的二分查找/","link":"","permalink":"https://ccxiao5.github.io/2021/07/16/STL%E4%B8%AD%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"使用的时候注意：必须用在非递减的区间中 二分查找的原理非常简单，但写出的代码中很容易含有很多Bug，二分查找一文中讲解过如何实现不同类型的二分查找，但是否一定要自己去实现二分查找呢？答案显然是否定的，本文将讲解STL中与二分查找有关函数的具体使用方法及其实现原理。 函数使用 STL中与二分查找相关的函数有4个，分别是lower_bound, upper_bound, equal_range和binary_search，下面通过一个简单的例子说明各个函数的使用方法。 其中每个函数实现的功能如下： binary_search：查找某个元素是否出现。 lower_bound：查找第一个大于或等于某个元素的位置。 upper_bound：查找第一个大于某个元素的位置。 equal_range：查找某个元素出现的起止位置。注意，终止位置为最后一次出现的位置加一。 binary_search试图在已排序的[first, last)中寻找元素value。如果[first, last)内有等价于value的元素，它会返回true，否则返回false，它不返回查找位置。 lower_bound它试图在已排序的[first,last)中寻找元素value。如果[first, last)具有等价于value的元素，lower_bound返回一个iterator指向其中第一个元素。如果没有这样的元素存在，它便返回假设这样的元素存在的话，会出现的位置。即指向第一个不小于value的元素。如果value大于[first, last)的任何一个元素，则返回last。 upper_bound它试图在已排序的[first,last)中寻找value，返回可安插value的最后一个合适的位置。如果value存在，lower_bound 返回的是指向该元素的iterator。相较之下upper_bound并不这么做，它返回value可被安插的最后一个合适位置。如果value存在，那么它返回的iterator将指向value的下一个位置，而非value自身。 equal_range的返回值本质上结合了lower_bound和upper_bound两者的返回值。其返回值是一对iterator i和j ,其中i是value可安插的第一个位置，j则是value可安插的最后一个位置。可以推演出：[i，j)中的每个元素都等价于value，而且[i, j)是[first, last)之中符合上述性质的一个最大子区间。 算法lower_bound返回该range的第一个iterator， 算法upper_bound返回该range的past-the-end iterator，算法equal_range则是以pair的形式将两者都返回。 STL 中的 lower_bound()， 函数lower_bound()在first和last中的前闭后开区间进行二分查找，返回大于或等于val的第一个元素位置。如果所有元素都小于val，则返回last的位置 举例如下： 一个数组number序列为：4,10,11,30,69,70,96,100.设要插入数字3,9,111.pos为要插入的位置的下标 则 pos = lower_bound( number, number + 8, 3) - number，pos = 0.即number数组的下标为0的位置。 pos = lower_bound( number, number + 8, 9) - number， pos = 1，即number数组的下标为1的位置（即10所在的位置）。 pos = lower_bound( number, number + 8, 111) - number， pos = 8，即number数组的下标为8的位置（但下标上限为7，所以返回最后一个元素的下一个元素）。 所以，要记住：函数lower_bound()在first和last中的前闭后开区间进行二分查找，返回大于或等于val的第一个元素位置。如果所有元素都小于val，则返回last的位置，且last的位置是越界的！！ 12345678910111213141516171819#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;string&gt; #include &lt;iostream&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; int main() &#123; int point[10] = &#123;1,3,7,7,9&#125;; int tmp = upper_bound(point, point + 5, 7)- point;//按从小到大，7最多能插入数组point的哪个位置 printf(&quot;%d\\n&quot;,tmp); tmp = lower_bound(point, point + 5, 7) - point;////按从小到大，7最少能插入数组point的哪个位置 printf(&quot;%d\\n&quot;,tmp); return 0; &#125;","categories":[{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/categories/C/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://ccxiao5.github.io/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://ccxiao5.github.io/tags/STL/"}]},{"title":"STL--set","slug":"STL-set","date":"2021-07-16T06:06:44.000Z","updated":"2021-07-16T07:28:25.513Z","comments":true,"path":"2021/07/16/STL-set/","link":"","permalink":"https://ccxiao5.github.io/2021/07/16/STL-set/","excerpt":"","text":"set集合容器：实现了红黑树的平衡二叉检索树的数据结构，插入元素时，它会自动调整二叉树的排列，把元素放到适当的位置，以保证每个子树根节点键值大于左子树所有节点的键值，小于右子树所有节点的键值；另外，还得保证根节点左子树的高度与右子树高度相等。 平衡二叉检索树使用中序遍历算法，检索效率高于vector、deque和list等容器，另外使用中序遍历可将键值按照从小到大遍历出来。 构造set集合主要目的是为了快速检索，不可直接去修改键值.并且set容器中有去重的效果 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;set&lt;int&gt; s;set&lt;int&gt;::iterator it;int main()&#123; s.insert(4); s.insert(2); s.insert(1); s.insert(3); s.insert(5); s.insert(1); for(it = s.begin(); it != s.end(); it++) cout&lt;&lt;*it&lt;&lt;&quot; &quot;; cout&lt;&lt;endl&lt;&lt;s.size()&lt;&lt;endl;; it = s.end(); s.erase(4); for(it = s.begin(); it != s.end(); it++) cout&lt;&lt;*it&lt;&lt;&quot; &quot;; cout&lt;&lt;endl&lt;&lt;*s.find(1)&lt;&lt;endl; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/categories/C/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://ccxiao5.github.io/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://ccxiao5.github.io/tags/STL/"}]},{"title":"STL总结","slug":"STL总结","date":"2021-07-16T06:06:30.000Z","updated":"2021-07-16T07:52:23.215Z","comments":true,"path":"2021/07/16/STL总结/","link":"","permalink":"https://ccxiao5.github.io/2021/07/16/STL%E6%80%BB%E7%BB%93/","excerpt":"","text":"见：http://www.cnblogs.com/biyeymyhjob/archive/2012/07/22/2603525.html","categories":[{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/categories/C/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://ccxiao5.github.io/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://ccxiao5.github.io/tags/STL/"}]},{"title":"STL--set_difference","slug":"STL-set-difference","date":"2021-07-16T03:35:14.000Z","updated":"2021-07-16T07:52:21.188Z","comments":true,"path":"2021/07/16/STL-set-difference/","link":"","permalink":"https://ccxiao5.github.io/2021/07/16/STL-set-difference/","excerpt":"","text":"set_difference（），作用是求两个集合的差。即求A-B(属于A但不属于B的元素) set_difference()算法计算两个集合[start1, end1)和[start2, end2)的差集, 并将差集存放到result. 两个集合以序列的形式给出, 且必须先按升序排好位置. set_difference()是一个指向result序列末尾的迭代器. 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int a[100],b[100];int main()&#123; int n,m; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) &#123; if(n == 0 &amp;&amp; m == 0) break; int i; for(i = 0;i &lt; n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(i = 0;i &lt; m;i++) scanf(&quot;%d&quot;,&amp;b[i]); sort(a,a + n); sort(b,b + m); vector&lt;int&gt; v(100); vector&lt;int&gt;::iterator it; it = set_difference(a,a + n,b,b + m,v.begin()); v.resize(it-v.begin()); if(v.size() == 0) cout&lt;&lt;&quot;NULL&quot;&lt;&lt;endl; else &#123; for(it = v.begin(); it != v.end(); it++) cout&lt;&lt;*it&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; &#125; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/categories/C/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://ccxiao5.github.io/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://ccxiao5.github.io/tags/STL/"}]},{"title":"priority_queue和sort应用","slug":"priority-queue和sort应用","date":"2021-07-16T03:34:42.000Z","updated":"2021-07-16T07:52:08.389Z","comments":true,"path":"2021/07/16/priority-queue和sort应用/","link":"","permalink":"https://ccxiao5.github.io/2021/07/16/priority-queue%E5%92%8Csort%E5%BA%94%E7%94%A8/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243#include&quot;iostream&quot;#include&quot;String&quot;#include&quot;stdio.h&quot;#include &quot;string.h&quot;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;class Number&#123; public: int a; bool operator &lt;(const Number &amp;m) const&#123; return a &gt; m.a; &#125;&#125;;priority_queue&lt;Number&gt; q;bool compare(int a,int b)&#123; return a &gt; b;//如果是&gt;就是从大到小，是&lt;就是从小到大&#125;int main()&#123; Number num[5]; num[0].a = 3; num[1].a = 5; num[2].a = 2; num[3].a = 9; num[4].a = 1; int i; for(i = 0;i &lt; 5;i++) q.push(num[i]); while(!q.empty()) &#123; cout&lt;&lt;q.top().a&lt;&lt;&quot;\\t&quot;; q.pop(); &#125; cout&lt;&lt;endl; int a[5] = &#123;3,5,2,9,1&#125;; sort(a,a+5,compare); for(i = 0 ;i &lt; 5; i++) cout&lt;&lt;a[i]&lt;&lt;&quot;\\t&quot;;&#125; 结果如下","categories":[{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/categories/C/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://ccxiao5.github.io/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://ccxiao5.github.io/tags/STL/"}]},{"title":"16进制转化8进制---map","slug":"16进制转化8进制-map","date":"2021-07-16T03:34:26.000Z","updated":"2021-07-16T07:51:58.997Z","comments":true,"path":"2021/07/16/16进制转化8进制-map/","link":"","permalink":"https://ccxiao5.github.io/2021/07/16/16%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8C%968%E8%BF%9B%E5%88%B6-map/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &quot;stdio.h&quot;#include &quot;string.h&quot;#include &quot;string&quot;#include &quot;iostream&quot;#include &quot;math.h&quot;#include &quot;map&quot;#include &quot;queue&quot;#include &quot;malloc.h&quot;using namespace std;map&lt;char,string&gt; mp;int main()&#123; mp[&#x27;0&#x27;]=&quot;0000&quot;;mp[&#x27;1&#x27;]=&quot;0001&quot;;mp[&#x27;2&#x27;]=&quot;0010&quot;;mp[&#x27;3&#x27;]=&quot;0011&quot;;mp[&#x27;4&#x27;]=&quot;0100&quot;; mp[&#x27;5&#x27;]=&quot;0101&quot;;mp[&#x27;6&#x27;]=&quot;0110&quot;;mp[&#x27;7&#x27;]=&quot;0111&quot;;mp[&#x27;8&#x27;]=&quot;1000&quot;;mp[&#x27;9&#x27;]=&quot;1001&quot;; mp[&#x27;A&#x27;]=&quot;1010&quot;;mp[&#x27;B&#x27;]=&quot;1011&quot;;mp[&#x27;C&#x27;]=&quot;1100&quot;;mp[&#x27;D&#x27;]=&quot;1101&quot;;mp[&#x27;E&#x27;]=&quot;1110&quot;; mp[&#x27;F&#x27;]=&quot;1111&quot;; int a; char test[100005]; cin &gt;&gt; a; while(a--) &#123; memset(test,0,sizeof(test)); string b=&quot;&quot;; cin&gt;&gt;test; for(int i = 0;i &lt; strlen(test);i++) &#123; b += mp[test[i]]; &#125; int len = b.length(); if(len%3==1) b = &quot;00&quot; + b; else if(len%3==2) b = &quot;0&quot; + b; int flag = 0; for(int i = 0 ;i &lt; b.length(); i = i + 3) &#123; int num = 4*(b[i]-&#x27;0&#x27;)+2*(b[i+1]-&#x27;0&#x27;)+(b[i+2]-&#x27;0&#x27;); if(num) flag = 1; if(flag) cout&lt;&lt;num; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 但是这个跑在蓝桥杯的题目中会超时，因为map查询是对数时间复杂度放在循环中会超时 更改map后通过 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &quot;stdio.h&quot;#include &quot;string.h&quot;#include &quot;string&quot;#include &quot;iostream&quot;#include &quot;math.h&quot;#include &quot;map&quot;#include &quot;queue&quot;using namespace std;map&lt;char,string&gt; mp;int main()&#123; int a; string test; cin &gt;&gt; a; while(a--) &#123; string b=&quot;&quot;; cin&gt;&gt;test; for(int i=0;i&lt;test.length();i++)//遍历，字符串上加上每一位 &#123; switch(test[i]) &#123; case &#x27;0&#x27;:b+=&quot;0000&quot;;break; case &#x27;1&#x27;:b+=&quot;0001&quot;;break; case &#x27;2&#x27;:b+=&quot;0010&quot;;break; case &#x27;3&#x27;:b+=&quot;0011&quot;;break; case &#x27;4&#x27;:b+=&quot;0100&quot;;break; case &#x27;5&#x27;:b+=&quot;0101&quot;;break; case &#x27;6&#x27;:b+=&quot;0110&quot;;break; case &#x27;7&#x27;:b+=&quot;0111&quot;;break; case &#x27;8&#x27;:b+=&quot;1000&quot;;break; case &#x27;9&#x27;:b+=&quot;1001&quot;;break; case &#x27;A&#x27;:b+=&quot;1010&quot;;break; case &#x27;B&#x27;:b+=&quot;1011&quot;;break; case &#x27;C&#x27;:b+=&quot;1100&quot;;break; case &#x27;D&#x27;:b+=&quot;1101&quot;;break; case &#x27;E&#x27;:b+=&quot;1110&quot;;break; case &#x27;F&#x27;:b+=&quot;1111&quot;;break; default:break; &#125; &#125; int len = b.length(); if(len%3==1) b = &quot;00&quot; + b; else if(len%3==2) b = &quot;0&quot; + b; int flag = 0; for(int i = 0 ;i &lt; b.length(); i = i + 3) &#123; int num = 4*(b[i]-&#x27;0&#x27;)+2*(b[i+1]-&#x27;0&#x27;)+(b[i+2]-&#x27;0&#x27;); if(num) flag = 1; if(flag) cout&lt;&lt;num; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/categories/C/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://ccxiao5.github.io/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://ccxiao5.github.io/tags/STL/"}]},{"title":"requirejs的使用和快速理解","slug":"requirejs的使用和快速理解","date":"2021-07-16T03:33:25.000Z","updated":"2021-07-16T07:12:19.394Z","comments":true,"path":"2021/07/16/requirejs的使用和快速理解/","link":"","permalink":"https://ccxiao5.github.io/2021/07/16/requirejs%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3/","excerpt":"","text":"requirejs有以下功能 声明不同js文件之间的依赖 可以按需、并行、延时载入js库 可以让我们的代码以模块化的方式组织 初看起来并不复杂。 创建以下目录 在HTML中，添加&lt;script&gt;标签：&lt;script data-main=&quot;js/script/main&quot; src=&quot;js/lib/require.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Require Demo 1&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h1&gt;Require Demo 1 -- usage of Require()&lt;/h1&gt; &lt;button id=&quot;contentBtn&quot;&gt;Click me&lt;/button&gt; &lt;p id=&quot;messagebox&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;script data-main=&quot;js/script/main&quot; src=&quot;js/lib/require.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; requirejs对外暴露的变量其实就三个,requirejs,require,define。这其中requirejs 只是require的一个别名，目的是如果页面中有require其它实现了，你还是能通过使用requirejs来使用requireJS API的(本文中没有相关冲突，所以还是使用require)。 我们可以看到在script标签中我们加载了require.js，其中有一个data-main，他是在require.js加载完成后通过回调的方法去加载data-main里的js 这是我们的main.js 12345678910111213141516171819202122232425262728// js/script/main.js require.config( &#123; paths: &#123;//一个模块ID和路径的映射，这样在后续的所有函数中就可以直接通过模块ID来引入依赖，而不用再多次引入依赖多次输入路径带来的麻烦。 jquery: &#x27;../lib/jquery-1.11.1&#x27;, chw_desc:&#x27;desc&#x27;, chw_alertdesc:&#x27;alertdesc&#x27;, chw_alert:&#x27;alert&#x27; &#125;, // shim:&#123; // &#x27;alert&#x27;: &#123;exports: &#x27;f&#x27;&#125; // &#125; &#125; ); require([&#x27;jquery&#x27;],function ($) &#123; $(document).on(&#x27;click&#x27;,&#x27;#contentBtn&#x27;,function()&#123; $(&#x27;#messagebox&#x27;).html(&#x27;You have access Jquery by using require()&#x27;); require([&#x27;desc&#x27;],function(chw)&#123; alert(&#x27;desc: &#x27;+JSON.stringify(chw)); &#125;); // require([&#x27;chw_alertdesc&#x27;],function(t)&#123; // alert(&#x27;alertdest: &#x27;+JSON.stringify(t)); // &#125;); // require([&#x27;alert&#x27;],function(chw)&#123; // chw(); // &#125;); &#125;); &#125;); 首先看最基础的decs.js（没有任何依赖） 他的require函数接受的第一个参数是所依赖模块的一个数组，即要想执行我的回调函数，你必须加载完desc.js这个文件，如果你有如本例子中设置了模块ID和路径的映射，那你在传入依赖的时候就可以使用模块ID来代替路径（我可以换成require([‘chw_desc’],function(chw){})），如果没有配置模块ID你当然也可以通过路径来引进对应的模块。接着是传入回调函数，当引入的依赖加载完毕后，这个回调函数就会被触发。如果你传入的依赖有注入变量（函数）,然后在回调函数中需要用到，你就需要按照顺序在回调函数的参数中添加别名，在本例子中可以通过别名$来使用jQuery的相关API(你也可以换成其他的符号比如‘G’,'F’等等)。 看看desc.js代码，没有任何依赖，desc.js他定义了一个模块，define(name, deps, callback)第一个参数是定义模块名，第二个参数是传入定义模块所需要的依赖，第三个函数则是定义模块的主函数，主函数和require的回调函数一样，同样是在依赖加载完以后再调用执行。第一参数不是很必要，因为如果哪一天我将这个文件转移到其他目录下，那我就得在这这里再修改一次模块名。 12345define(function()&#123; return&#123; desc:&#x27;this js will be request only if it is needed&#x27;, &#125;;&#125; 在看看alertdesc,js(依赖于desc.js) 12345define([&#x27;desc&#x27;],function()&#123; return&#123; desc:&#x27;this js will be request only if it is needed&#x27;, &#125;;&#125;) 同样在require函数里面可以写成 require([‘alertdesc’],function(t){}) alert.js. (加载非规范的模块没使用define定义模块) 123function f() &#123; alert(&quot;hahah&quot;);&#125; require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性，他就是将某个依赖中的某个全局变量暴露给requirejs，当作这个模块本身的引用。 123shim:&#123; &#x27;alert&#x27;: &#123;exports: &#x27;f&#x27;&#125; &#125; 由于我这个模块没有依赖，所以没必要写deps，上面的代码表示的是在’alert’（在相对路径下的alert.js文件中），把f函数暴露出来成为全局可用，那当我们的代码依赖于 alert 模块的时候，就可以拿到这个 f 函数的引用了。注意的是require(['alert'],function(chw)&#123;&#125;&#125;);不能换成require(['chw_alert'],function(chw)&#123;&#125;&#125;);因为在你暴露变量的时候你是暴露给模块名为’alert’，所以对于其他的模块并不是全局可用，如果要换成chw_alert，那么shim中应该这样写shim:{‘chw_alert’:{exports:‘f’}}","categories":[{"name":"web","slug":"web","permalink":"https://ccxiao5.github.io/categories/web/"}],"tags":[{"name":"requirejs","slug":"requirejs","permalink":"https://ccxiao5.github.io/tags/requirejs/"}]},{"title":"Bootstrap滚动监视原理实现","slug":"Bootstrap滚动监视原理实现","date":"2021-07-16T03:32:52.000Z","updated":"2021-07-16T06:55:30.199Z","comments":true,"path":"2021/07/16/Bootstrap滚动监视原理实现/","link":"","permalink":"https://ccxiao5.github.io/2021/07/16/Bootstrap%E6%BB%9A%E5%8A%A8%E7%9B%91%E8%A7%86%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"最近在公司实习，刚好写了一个静态的网页，用到了滚动监视，就自己写了个监视，话不多说直接进入正题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151$(function () &#123; var $root = $(&quot;html,body&quot;); var location = [];//存储item active属性状态 true表示有class=&quot;active&quot; location[&quot;position_1&quot;] = false; location[&quot;position_2&quot;] = false; location[&quot;position_3&quot;] = false; location[&quot;position_4&quot;] = false; location[&quot;position_5&quot;] = false; location[&quot;position_6&quot;] = false; location[&quot;position_7&quot;] = false; var offset1,offset2,offset3, offset4,offset5,offset6,offset7; //各个锚点的距离顶部的偏移 offset1 = $(&quot;[name = position_1]&quot;).offset().top - 2 * parseInt($(&quot;.header_top&quot;).css(&quot;height&quot;).toString().split(&quot;px&quot;)[0]); offset2 = $(&quot;[name = position_2]&quot;).offset().top - 2 * parseInt($(&quot;.header_top&quot;).css(&quot;height&quot;).toString().split(&quot;px&quot;)[0]); offset3 = $(&quot;[name = position_3]&quot;).offset().top - 2 * parseInt($(&quot;.header_top&quot;).css(&quot;height&quot;).toString().split(&quot;px&quot;)[0]); offset4 = $(&quot;[name = position_4]&quot;).offset().top - 2 * parseInt($(&quot;.header_top&quot;).css(&quot;height&quot;).toString().split(&quot;px&quot;)[0]); offset5 = $(&quot;[name = position_5]&quot;).offset().top - 2 * parseInt($(&quot;.header_top&quot;).css(&quot;height&quot;).toString().split(&quot;px&quot;)[0]); offset6 = $(&quot;[name = position_6]&quot;).offset().top - 2 * parseInt($(&quot;.header_top&quot;).css(&quot;height&quot;).toString().split(&quot;px&quot;)[0]); offset7 = offset6 + parseInt($(&quot;#section_6&quot;).css(&quot;height&quot;).toString().split(&quot;px&quot;)[0]) / 2;//最后部分高度不够，不能按部就班，否则滚动条到不到指定位置就倒底了 function initi () &#123; for(var i in location) location[i] = false; &#125; // debugger; $(window).scroll(function () &#123; // debugger; var Scroll = $(document).scrollTop(); $(&quot;[class = &#x27;active&#x27;]&quot;).removeAttr(&quot;class&quot;); if(Scroll &lt; offset2 &amp;&amp; Scroll &gt;= offset1) &#123; initi(); $(&quot;[href =#position_1]&quot;).parent().attr(&quot;class&quot;, &quot;active&quot;); location[&quot;position_1&quot;] = true; &#125; else if(Scroll &lt; offset3 &amp;&amp; Scroll &gt;= offset2) &#123; initi(); $(&quot;[href =#position_2]&quot;).parent().attr(&quot;class&quot;,&quot;active&quot;); location[&quot;position_2&quot;] = true; &#125; else if(Scroll &lt; offset4 &amp;&amp; Scroll &gt;= offset3)&#123; initi(); $(&quot;[href =#position_3]&quot;).parent().attr(&quot;class&quot;,&quot;active&quot;); location[&quot;position_3&quot;] = true; &#125; else if(Scroll &lt; offset5 &amp;&amp; Scroll &gt;= offset4) &#123; initi(); $(&quot;[href =#position_4]&quot;).parent().attr(&quot;class&quot;, &quot;active&quot;); location[&quot;position_4&quot;] = true; &#125; else if(Scroll &lt; offset6 &amp;&amp; Scroll &gt;= offset5) &#123; initi(); $(&quot;[href =#position_5]&quot;).parent().attr(&quot;class&quot;, &quot;active&quot;); location[&quot;position_5&quot;] = true; &#125; else if(Scroll &lt; offset7 &amp;&amp; Scroll &gt;= offset6)&#123; initi(); $(&quot;[href =#position_6]&quot;).parent().attr(&quot;class&quot;, &quot;active&quot;); location[&quot;position_6&quot;] = true; &#125; else &#123; initi(); $(&quot;[href =#position_7]&quot;).parent().attr(&quot;class&quot;, &quot;active&quot;); location[&quot;position_7&quot;] = true; &#125; &#125;); $(&quot;a&quot;).on(&quot;click&quot;,function (e) &#123; var event = e || window.event; var son = $(event.target); var father = son.parent(); var Name = father.prop(&quot;tagName&quot;); if(Name == &quot;LI&quot;) &#123; var act = $(&quot;[class =&#x27;active&#x27;]&quot;).children(&quot;a&quot;).attr(&quot;href&quot;).toString().split(&quot;#&quot;)[1]; location[act] = false; $(&quot;[class =&#x27;active&#x27;]&quot;).removeAttr(&quot;class&quot;); var pos = son.attr(&quot;href&quot;).toString().split(&quot;#&quot;)[1]; location[pos] = true; $root.animate(&#123; scrollTop: $(&quot;[name=\\&quot;&quot; + pos + &quot;\\&quot;]&quot;).offset().top &#125;, 1000); father.attr(&quot;class&quot;, &quot;active&quot;); return false; &#125; else if(Name == &quot;A&quot;) &#123; var flag = false,pri,real,next,total = 0; var temp,num_next = 0,num_pri = 0; for(var i in location) &#123; if(location[i]) &#123; flag = true; break; &#125; &#125; if(flag == false) &#123; location[&quot;position_1&quot;] = true; window.location.href = &quot;#position_1&quot;; &#125; for (i in location) &#123; total++; if (location[i]) &#123; temp = i.split(&quot;_&quot;); num_next = parseInt(temp[1]) + 1; num_pri = parseInt(temp[1]) - 1; if(total == 1) &#123; pri = real = i; next = temp[0] + &quot;_&quot; + num_next; &#125; else if(total == 7) &#123; next = real = i; pri = temp[0] + &quot;_&quot; + num_pri; &#125; else &#123; next = temp[0] + &quot;_&quot; + num_next; real = i; pri = temp[0] + &quot;_&quot; + num_pri; &#125; break; &#125; &#125; if(son.hasClass(&quot;prev&quot;)) &#123; location[real] = false; location[pri] = true; $root.animate(&#123; scrollTop: $(&quot;[name=\\&quot;&quot; + pri + &quot;\\&quot;]&quot;).offset().top &#125;, 1000); $(&quot;[class =&#x27;active&#x27;]&quot;).removeAttr(&quot;class&quot;); $(&quot;[href=\\&quot;#&quot; + pri + &quot;\\&quot;]&quot;).parent().attr(&quot;class&quot;,&quot;active&quot;); return false; &#125; else if(son.hasClass(&quot;next&quot;)) &#123; location[real] = false; location[next] = true; $root.animate(&#123; scrollTop: $(&quot;[name=\\&quot;&quot; + next + &quot;\\&quot;]&quot;).offset().top &#125;, 1000); $(&quot;[class=&#x27;active&#x27;]&quot;).removeAttr(&quot;class&quot;); $(&quot;[href=\\&quot;#&quot; + next + &quot;\\&quot;]&quot;).parent().attr(&quot;class&quot;,&quot;active&quot;); return false; &#125; else return false; &#125; &#125;);&#125;); 在实习的时候做页面出现的几个问题 1.图片自适应浏览器窗口完全显示 查看图片的长宽 设置所在图片div的padding-top为高/宽 比如，一张图片是 2000*1333 那么设置所在div padding-top:66.65%; 在div里面放空的block标签强行撑开 然后在div中设置background: url(&quot;…/picture/bg.jpg&quot;) no-repeat;background-size: cover; 2.滚动监视的时候发生的锚点偏移问题，过了锚点，还没触发了事件 这种情况是因为头部设置了一个固定位置的div，从而导致这个div就不占空间了，他下面的元素就填充他的位置。 解决不占空间的方法：1.设置margin-top 2.设置一个空div 解决锚点偏移的方法：设置暗锚来填充形成的固定位置的div 1234567&lt;div id=&quot;section_2&quot; class=&quot;container&quot;&gt; &lt;a name=&quot;position_2&quot; class=&quot;target-fix&quot;&gt;&lt;/a&gt; &lt;h1&gt;信息15-1&lt;/h1&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt; &lt;p&gt;To be or not to be,that&#x27;s a question.&lt;br/&gt;&lt;br/&gt; 决心不过是记忆的奴隶 它会根据你的记忆随意更改(When sorrows come, they come not single spies, - but in battalions.)&lt;br/&gt;&lt;br/&gt; &lt;/p&gt; &lt;/div&gt; 123456.target-fix&#123; display: block; position: relative; top: -65px;&#125; 比如说我的固定位置的div高度是65px，那么我这个暗锚就上移65px，然后我就只用跳转到这个锚点位置就行&lt;li&gt;&lt;a href=&quot;#position_2&quot;&gt;信息15-1&lt;/a&gt;&lt;/li&gt; 原理：虽然元素被fixed在最上面了，可是页面计算section_2的页边距报读的时候还是把fixed的高度算上去了，所以点击锚点链接的时候，偏移的距离是section_2页边距的高度加上fixed的高度(section_2.offset().top + nav.height)所以设置暗锚向上偏移65px; 因为写的是静态页面 写的很随意把页面写死了 css文件里出现的多余的样式是因为我直接把实习的工程文件截取抽过来，所以代码就很难看了~~~~~~想要看看效果的就自行查看百度云链接：https://pan.baidu.com/s/1kWDK8rP 密码：6de2","categories":[{"name":"web","slug":"web","permalink":"https://ccxiao5.github.io/categories/web/"}],"tags":[{"name":"bootstrap","slug":"bootstrap","permalink":"https://ccxiao5.github.io/tags/bootstrap/"},{"name":"javascript","slug":"javascript","permalink":"https://ccxiao5.github.io/tags/javascript/"}]},{"title":"Bootstrap模态框原理分析及问题解决","slug":"Bootstrap模态框原理分析及问题解决","date":"2021-07-16T03:32:13.000Z","updated":"2021-07-16T07:54:36.919Z","comments":true,"path":"2021/07/16/Bootstrap模态框原理分析及问题解决/","link":"","permalink":"https://ccxiao5.github.io/2021/07/16/Bootstrap%E6%A8%A1%E6%80%81%E6%A1%86%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","excerpt":"","text":"最近自学了bootstrap觉得里面模板样式挺好的，就想自己实现实现，不多说了，开始进入正题了 今天就来实现bootstrap里面的模态框弹出效果 首先很简单 实现一个类似于panel的modal 1234567891011121314151617181920&lt;body&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; style=&quot;display: block;margin: 20px auto;&quot;&gt;Click me!&lt;/button&gt;&lt;div class=&quot;chw-dialog&quot;&gt; &lt;div class=&quot;chw-modal&quot;&gt; &lt;div class=&quot;chw-title&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot;&gt; &lt;span&gt;×&lt;/span&gt; &lt;/button&gt; &lt;h4&gt;chw-Modal title&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;chw-content&quot;&gt; &lt;p&gt;fantasy baby&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;chw-footer&quot;&gt; &lt;button class=&quot;btn btn-info&quot;&gt;Save changes&lt;/button&gt; &lt;button class=&quot;btn btn-default&quot;&gt;Close&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556.chw-dialog &#123; display: none; position: fixed; top:0; right: 0; bottom: 0; left: 0; z-index: 1100; opacity: 0; transition : opacity .15s linear; &#125; .chw-modal&#123; width: 600px; margin: 30px auto; box-shadow: 0 5px 10px rgba(0,0,0,.5); border-radius: 6px; border: 1px solid rgba(0,0,0,.5); z-index: 1200; background-color: white; transform: translate(0,-25%); transition: transform 0.3s ease-out; &#125; .chw-panel&#123; position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 1024; background-color: black; opacity: 0; transition : opacity .15s linear; &#125; .chw-title&#123; padding:15px; border-bottom: 1px solid #dddddd; &#125; .chw-title h4&#123; line-height: 1.4; font-size: 23px; margin: 0; &#125; .chw-content&#123; padding:15px; border-bottom: 1px solid #dddddd; &#125; .chw-footer&#123; padding: 15px; clear: both; overflow: hidden; &#125; .chw-footer button&#123; float: right; margin-right: 10px; &#125; &lt;/style&gt; 好了不多说开始重点部分，先看看bootstrap的源代码，点击button后 发现有一个后面有一个蒙层 看见myModa和其子元素都没有background-color和opacity结合使用的，说明这个蒙层不是myModal生成的，那这个蒙层是怎么生成的？ 我把myModal的类全部删除后(剔除css样式)发现蒙层还在，从而更加确信了我的猜测，然后用chrome去获取蒙层发现这个蒙层在整个html最下面。 那为什么一开始没有索取到这个元素能，因为z-index的效果 这个蒙层div(z-index:1040;)在modal类的下面(z-index:1050;)退出后，这个蒙层div就没有了，说明通过js添加 好了在清楚大体css结构的时候我们自己来写一个类似的弹出功能点击按钮，js生成蒙层你的modal点击周围或者退出按钮时蒙层删除modal隐藏。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;script&gt; $(&quot;body&gt;button&quot;).on(&#x27;click&#x27;,function () &#123; var temp = &quot;&lt;div class=&#x27;chw-panel&#x27;&gt;&lt;/div&gt;&quot;; $(&quot;body&quot;).append(temp); $(&quot;.chw-dialog&quot;).css(&quot;display&quot;,&quot;block&quot;); setTimeout(function()&#123;//后续会说明setTimeout $(&quot;.chw-panel&quot;).css(&quot;opacity&quot;,&quot;0.5&quot;); $(&quot;.chw-dialog&quot;).css(&quot;opacity&quot;,&quot;1&quot;); $(&quot;.chw-modal&quot;).css( &quot;transform&quot;,&quot;translate(0,0)&quot;); &#125;,1); &#125;); $(&#x27;.chw-dialog&#x27;).on(&#x27;click&#x27;,function()&#123; debugger; $(&quot;.chw-panel&quot;).css(&quot;opacity&quot;,&quot;0&quot;); $(&quot;.chw-dialog&quot;).css(&quot;opacity&quot;,&quot;0&quot;); $(&quot;.chw-modal&quot;).css( &quot;transform&quot;,&quot;translate(0,-25%)&quot;); setTimeout(function () &#123; $(&quot;.chw-dialog&quot;).hide(); $(&quot;.chw-panel&quot;).remove(); &#125;,1); &#125;); $(&quot;.chw-modal&quot;).click(function (e) &#123; e.stopPropagation(); return false; &#125;); $(&quot;.close&quot;).click(function () &#123; $(&quot;.chw-panel&quot;).css(&quot;opacity&quot;,&quot;0&quot;); $(&quot;.chw-dialog&quot;).css(&quot;opacity&quot;,&quot;0&quot;); $(&quot;.chw-modal&quot;).css( &quot;transform&quot;,&quot;translate(0,-25%)&quot;); setTimeout(function () &#123; $(&quot;.chw-dialog&quot;).hide(); $(&quot;.chw-panel&quot;).remove(); &#125;,1); &#125;);&lt;/script&gt;``` 首先我是先完成大概功能即点击按钮显示然后退出没有考虑动画，在实现的时候发现了几个问题： &lt;b&gt;1.点击按钮后生成蒙层没有问题，但是点击modal以外部分没有退出，没有任何反应。(这个问题是因为在实现蒙层的点击生成退出的时候发现的，但实际上是点击chw-dialog来关闭的因为他的z-index高于那个蒙层div的z-index)&lt;/b&gt; &amp;emsp;&lt;b&gt;解决方法：使用$.on()，jquery版本1.7+&lt;/b&gt; &amp;emsp;&lt;font color=&quot;red&quot;&gt;因为我原来写的函数是`$(&#x27;.chw-panel&#x27;).click(function()&#123;&#125;)`无论怎么点击那个蒙层也不会触发函数，查阅资料后发现&lt;/font&gt;，我们在给动态添加的标签绑定事件的时候(给通过append添加过来的标签`&lt;span class=”test”&gt;&lt;/span&gt;`),不能直接写$(‘.test’).click(function()&#123;&#125;);是因为jquery他的事件机制是当页面完全加载成功后，会根据所有目前页面上符合要求的dom添加事件标示，这样当你触发事件的时候，拥有该事件标示的DOM就会给予响应。但append很可能是页面加载完成后，再触发的事件，这样的话，初始化的时候就没有成功加上，所以你不能简单的使用click,需要用on。由于事件的&lt;font color=&quot;red&quot;&gt;冒泡机制&lt;/font&gt;(如果子事件没有完成(没有定义子事件的处理函数)或者事件返回true，那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理(父级对象所有同类事件都将被激活)，或者它到达了对象层次的最顶层，即document对象(有些浏览器是window)举个例子我有个子事件没有被处理，那么他会传递到他的父级看看父级是否能解决，如果不能继续向上级传递直到解决为止)$(“body”).on(‘click’,’.test’,function()&#123;&#125;);这个表明是body这个对象绑定事件，如果body的子元素.test的div触发了点击事件，因为.test没有绑定事件(通过append添加的div)，那么他要向上传递，当传递到body的时候，body通过jquery知道是哪个子元素触发了函数，如果这个子元素刚好和自己选择的元素一致的话就执行函数。如果这样写`$(“body”).on(‘click’,function()&#123;&#125;)`;表明只要他的子元素触发事件都会执行函数，就像点击了body触发函数一样，然而实际是子元素触发事件传递到body执行函数。&lt;b&gt;2.无论点击哪个地方都会退出&lt;/b&gt; &amp;emsp;&lt;b&gt;解决方法：使用stopPropagation()&lt;/b&gt; &amp;emsp;如果我没有加红色的那段代码时，发现点击按钮后，无论我点击哪个地方都会退出，这和我们的预期不一样啊，他应该是点击modal以外的部分退出。怎么会出现这样的情况呢？因为我的.chw-modal是.chw-dialog的子元素，在定义事件触发函数的时候是这样写的$(&#x27;.chw-dialog&#x27;).on(&#x27;click&#x27;,function()&#123;&#125;);由于事件的冒泡机制，无论你点击.chw-dialog的任何子元素，在这些子元素没有绑定函数的前提下，你的子元素都会执行.chw-dialog绑定的函数在实现弹出退出后，添加延迟来实现动画过度```css.chw-dialog &#123; display: none; position: fixed; top:0; right: 0; bottom: 0; left: 0; z-index: 1100; opacity: 0; transition : opacity .15s linear;&#125;.chw-modal&#123; width: 600px; margin: 30px auto; box-shadow: 0 5px 10px rgba(0,0,0,.5); border-radius: 6px; border: 1px solid rgba(0,0,0,.5); z-index: 1200; background-color: white; transform: translate(0,-25%);//初始div位置 transition: transform 0.3s ease-out;&#125;.chw-panel&#123; position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 1024; background-color: black; opacity: 0; transition : opacity .15s linear;&#125; 在初始化位置和定义相应的transition后，接下来就是通过js添加css来触发动画，改变css的时候发现了一个问题，改变css后但是动画没有出现失效了，这是为什么呢？经过自己测试: ` $(\"button\").click(function(){$(\".test\").css(\"opacity\",\"1\");}); ` 发现可以实现动画效果，那为什么myModal的动画效果没有出来呢，经过查阅资料发现，如果在css中先执行了让display:none;变成block的操作的时候动画不会出现，原因是因为在js中语句几乎是同时执行，所以要想他们之间有个前后运行的效果 有两种办法 1.使用setTimeout来控制css属性值变化 2.使用animate在回调函数里面设置display(不能和transition同时使用) 解决了以上问题后就能做到类似的弹出效果啦是不是很炫~~~~~上面需要引用bootstrap.css","categories":[{"name":"web","slug":"web","permalink":"https://ccxiao5.github.io/categories/web/"}],"tags":[{"name":"bootstrap","slug":"bootstrap","permalink":"https://ccxiao5.github.io/tags/bootstrap/"}]},{"title":"C++ Map遍历","slug":"C-Map遍历","date":"2021-07-13T11:52:09.000Z","updated":"2021-07-16T07:51:47.287Z","comments":true,"path":"2021/07/13/C-Map遍历/","link":"","permalink":"https://ccxiao5.github.io/2021/07/13/C-Map%E9%81%8D%E5%8E%86/","excerpt":"","text":"1234567891011121314151617181920#include &quot;stdio.h&quot;#include &quot;string.h&quot;#include &quot;string&quot;#include &quot;iostream&quot;#include &quot;math.h&quot;#include &quot;map&quot;using namespace std;map&lt;char,string&gt; mp;map&lt;char,string&gt;::iterator it;int main(int argc, char const *argv[])&#123; mp[&#x27;0&#x27;]=&quot;0000&quot;;mp[&#x27;1&#x27;]=&quot;0001&quot;;mp[&#x27;2&#x27;]=&quot;0010&quot;;mp[&#x27;3&#x27;]=&quot;0011&quot;; mp[&#x27;4&#x27;]=&quot;0100&quot;;mp[&#x27;5&#x27;]=&quot;0101&quot;;mp[&#x27;6&#x27;]=&quot;0110&quot;;mp[&#x27;7&#x27;]=&quot;0111&quot;; mp[&#x27;8&#x27;]=&quot;1000&quot;;mp[&#x27;9&#x27;]=&quot;1001&quot;;mp[&#x27;A&#x27;]=&quot;1010&quot;;mp[&#x27;B&#x27;]=&quot;1011&quot;; mp[&#x27;C&#x27;]=&quot;1100&quot;;mp[&#x27;D&#x27;]=&quot;1101&quot;;mp[&#x27;E&#x27;]=&quot;1110&quot;;mp[&#x27;F&#x27;]=&quot;1111&quot;; for(it = mp.begin(); it != mp.end(); it++) //it-&gt;first下标的值，it-&gt;second所在下标的值 cout&lt;&lt;it-&gt;first&lt;&lt;&quot;:&quot;&lt;&lt;it-&gt;second&lt;&lt;endl; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/categories/C/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://ccxiao5.github.io/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://ccxiao5.github.io/tags/STL/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-07-13T10:01:34.483Z","updated":"2021-07-16T02:10:38.427Z","comments":true,"path":"2021/07/13/hello-world/","link":"","permalink":"https://ccxiao5.github.io/2021/07/13/hello-world/","excerpt":"","text":"H=−∑i=1N(σixσi+1x+gσiz)H=-\\sum_{i=1}^N (\\sigma_{i}^x \\sigma_{i+1}^x+g \\sigma_{i}^z) H=−i=1∑N​(σix​σi+1x​+gσiz​) f(n)={n2,if n is even3n+1,if n is oddf(n) = \\begin{cases} \\frac{n}{2}, &amp; \\text{if } n\\text{ is even} \\\\ 3n+1, &amp; \\text{if } n\\text{ is odd} \\end{cases} f(n)={2n​,3n+1,​if n is evenif n is odd​ Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/categories/C/"},{"name":"web","slug":"web","permalink":"https://ccxiao5.github.io/categories/web/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://ccxiao5.github.io/tags/ACM/"},{"name":"C++","slug":"C","permalink":"https://ccxiao5.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://ccxiao5.github.io/tags/STL/"},{"name":"requirejs","slug":"requirejs","permalink":"https://ccxiao5.github.io/tags/requirejs/"},{"name":"bootstrap","slug":"bootstrap","permalink":"https://ccxiao5.github.io/tags/bootstrap/"},{"name":"javascript","slug":"javascript","permalink":"https://ccxiao5.github.io/tags/javascript/"}]}